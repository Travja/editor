var Pr=Object.defineProperty;var Or=(s,e,t)=>e in s?Pr(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var r=(s,e,t)=>(Or(s,typeof e!="symbol"?e+"":e,t),t);import{S as ue,i as he,s as pe,y as z,z as Y,A as j,g as V,d as N,B as Z,k as S,q as Q,a as W,l as D,m as $,r as M,h as T,c as B,n as b,b as C,C as y,D as Ge,E as K,F as Oe,G as hr,w as ie,H as re,I as Ee,J as Xs,K as ze,L as pr,M as dr,N as fr,O as ce,P as Ie,Q as to,R as ao,T as we,U as Le,V as Lr,u as Ce,e as Se,W as Fr,v as $e,f as Pe,X as bo,Y as ko,Z as Ye,p as Vl,_ as Vr,o as mr,$ as Rr,a0 as gr,a1 as _o,a2 as Fe,a3 as ho,a4 as po,a5 as Rl,a6 as De,a7 as Nr,a8 as Nl}from"../chunks/index.15de7685.js";import{s as wr,l as qr,a as yr,g as Je,b as Ao,c as Js,P as He,d as Ke,u as Tr,e as Xe,i as et,f as vr,h as br,j as kr,k as xr,m as Hr,r as Cr,n as Qs,o as fo,p as go,q as mo,t as wo,v as yo,w as Wr,x as Br,y as Qe,z as Ur,A as Gr,B as Kr,C as zr,D as ql,E as xl,R as Ze,F as ne,G as Hl,H as Yr}from"../chunks/store.9125dc9d.js";import{M as Eo,a as To,P as qe,b as J,c as O,u as Cl}from"../chunks/targets.0ca3788e.js";import{f as xe,s as Ms,T as so,c as jr,P as be}from"../chunks/ProInput.187e6e71.js";import{M as _r,S as So,L as Zr,A as Xr,g as Do,a as Ar,b as Jr,c as Qr,d as Er,e as Mr,f as eo,h as ec,i as tc,j as ac,k as Sr,l as Dr,m as sc,n as oc,o as nc,p as ic,q as Wl,r as Ir,v as Bl,s as Ul}from"../chunks/AttributeInput.c37504bb.js";const vo="https://paste.travja.dev",lc=s=>{if(typeof s!="string")return Promise.reject(new Error('You cannot send that. Please include a "content" argument that is a valid string.'));if(s==="")return Promise.reject(new Error("You cannot send nothing."));const e={method:"POST",body:s,headers:{"Content-Type":"text/plain"}};return fetch(`${vo}/documents`,e).then(t=>t.json()).then(t=>{if(!t.key)throw new Error("Did not receive hastebin key.");return`${vo}/${t.key}`})},rc=async s=>(s.url&&(s.url.includes("astebin.com")||s.url.includes("paste.travja.dev"))&&!s.url.includes("raw")&&(s.url=s.url.replace(/(astebin\.com|paste\.travja\.dev)/,"$1/raw")),!s.url&&s.id&&(s.url=`${vo}/raw/${s.id}`),s.url?await(await fetch(s.url)).text():void 0);function cc(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A,p,f,m,k,E,U,x,se,L,G;return{c(){e=S("div"),t=S("div"),a=S("div"),o=Q("Upload File"),l=W(),n=S("label"),c=Q("Select File"),i=W(),u=S("input"),h=W(),d=S("div"),w=S("span"),v=Q("OR"),A=W(),p=S("div"),f=S("div"),m=Q("Import from URL"),k=W(),E=S("input"),U=W(),x=S("div"),se=Q("Import"),this.h()},l(ee){e=D(ee,"DIV",{class:!0});var P=$(e);t=D(P,"DIV",{class:!0});var H=$(t);a=D(H,"DIV",{});var te=$(a);o=M(te,"Upload File"),te.forEach(T),l=B(H),n=D(H,"LABEL",{for:!0,class:!0});var me=$(n);c=M(me,"Select File"),me.forEach(T),i=B(H),u=D(H,"INPUT",{id:!0,type:!0,class:!0}),H.forEach(T),h=B(P),d=D(P,"DIV",{class:!0});var de=$(d);w=D(de,"SPAN",{class:!0});var ye=$(w);v=M(ye,"OR"),ye.forEach(T),de.forEach(T),A=B(P),p=D(P,"DIV",{class:!0});var q=$(p);f=D(q,"DIV",{});var Te=$(f);m=M(Te,"Import from URL"),Te.forEach(T),k=B(q),E=D(q,"INPUT",{class:!0}),U=B(q),x=D(q,"DIV",{class:!0});var _e=$(x);se=M(_e,"Import"),_e.forEach(T),q.forEach(T),P.forEach(T),this.h()},h(){b(n,"for","file-upload"),b(n,"class","button"),b(u,"id","file-upload"),b(u,"type","file"),b(u,"class","hidden svelte-8b3mcy"),u.multiple=!0,b(t,"class","option svelte-8b3mcy"),b(w,"class","svelte-8b3mcy"),b(d,"class","or svelte-8b3mcy"),b(E,"class","svelte-8b3mcy"),b(x,"class","button"),b(p,"class","option svelte-8b3mcy"),b(e,"class","options svelte-8b3mcy")},m(ee,P){C(ee,e,P),y(e,t),y(t,a),y(a,o),y(t,l),y(t,n),y(n,c),y(t,i),y(t,u),y(e,h),y(e,d),y(d,w),y(w,v),y(e,A),y(e,p),y(p,f),y(f,m),y(p,k),y(p,E),Ge(E,s[1]),y(p,U),y(p,x),y(x,se),L||(G=[K(u,"change",s[4]),K(E,"input",s[5]),K(x,"click",s[3])],L=!0)},p(ee,P){P&2&&E.value!==ee[1]&&Ge(E,ee[1])},d(ee){ee&&T(e),L=!1,Oe(G)}}}function uc(s){let e,t;return e=new Eo({props:{open:!0,$$slots:{default:[cc]},$$scope:{ctx:s}}}),e.$on("close",s[2]),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&67&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function hc(s,e,t){let a,o;const l=()=>{t(1,a=t(0,o=void 0)),wr(!1)},n=()=>{a&&(a.startsWith("http")||t(1,a="https://"+a),rc({url:a}).then(u=>{l(),qr(u)}).catch(u=>{console.error(u)}))};function c(){o=this.files,t(0,o)}function i(){a=this.value,t(1,a)}return s.$$.update=()=>{if(s.$$.dirty&1&&o&&o.length>0)for(const u of o)u.name.indexOf(".yml")!=-1&&(yr(u),l())},[o,a,l,n,c,i]}class pc extends ue{constructor(e){super(),he(this,e,hc,uc,pe,{})}}function Gl(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A=s[2]instanceof He&&Kl(s);return{c(){e=S("div"),A&&A.c(),t=W(),a=S("div"),o=S("span"),l=Q("save"),c=W(),i=S("div"),u=S("span"),h=Q("delete"),this.h()},l(p){e=D(p,"DIV",{class:!0});var f=$(e);A&&A.l(f),t=B(f),a=D(f,"DIV",{class:!0,title:!0});var m=$(a);o=D(m,"SPAN",{class:!0});var k=$(o);l=M(k,"save"),k.forEach(T),m.forEach(T),c=B(f),i=D(f,"DIV",{class:!0,title:!0});var E=$(i);u=D(E,"SPAN",{class:!0});var U=$(u);h=M(U,"delete"),U.forEach(T),E.forEach(T),f.forEach(T),this.h()},h(){b(o,"class","material-symbols-rounded"),b(a,"class","download svelte-15m730s"),b(a,"title",n="Save "+(s[2].triggers?"Skill":"Class")),b(u,"class","material-symbols-rounded"),b(i,"class","delete svelte-15m730s"),b(i,"title",d="Delete "+(s[2].triggers?"Skill":"Class")),b(e,"class","buttons svelte-15m730s")},m(p,f){C(p,e,f),A&&A.m(e,null),y(e,t),y(e,a),y(a,o),y(o,l),y(e,c),y(e,i),y(i,u),y(u,h),w||(v=[K(a,"click",Xs(ze(s[13]))),K(i,"click",Xs(ze(s[14])))],w=!0)},p(p,f){p[2]instanceof He?A?A.p(p,f):(A=Kl(p),A.c(),A.m(e,t)):A&&(A.d(1),A=null),f&4&&n!==(n="Save "+(p[2].triggers?"Skill":"Class"))&&b(a,"title",n),f&4&&d!==(d="Delete "+(p[2].triggers?"Skill":"Class"))&&b(i,"title",d)},d(p){p&&T(e),A&&A.d(),w=!1,Oe(v)}}}function Kl(s){let e,t,a,o;return{c(){e=S("a"),t=S("span"),a=Q("edit"),this.h()},l(l){e=D(l,"A",{href:!0,class:!0,title:!0});var n=$(e);t=D(n,"SPAN",{class:!0});var c=$(t);a=M(c,"edit"),c.forEach(T),n.forEach(T),this.h()},h(){b(t,"class","material-symbols-rounded"),b(e,"href",o="/skill/"+s[2].name+"/edit"),b(e,"class","edit svelte-15m730s"),b(e,"title","Edit Skill")},m(l,n){C(l,e,n),y(e,t),y(t,a)},p(l,n){n&4&&o!==(o="/skill/"+l[2].name+"/edit")&&b(e,"href",o)},d(l){l&&T(e)}}}function dc(s){let e,t,a=s[2].name+"",o,l,n,c,i,u,h,d,w,v,A;return{c(){e=S("h3"),t=Q("Do you really want to delete "),o=Q(a),l=Q("?"),n=W(),c=S("div"),i=S("div"),u=Q("Cancel"),h=W(),d=S("div"),w=Q("Delete"),this.h()},l(p){e=D(p,"H3",{});var f=$(e);t=M(f,"Do you really want to delete "),o=M(f,a),l=M(f,"?"),f.forEach(T),n=B(p),c=D(p,"DIV",{class:!0});var m=$(c);i=D(m,"DIV",{class:!0});var k=$(i);u=M(k,"Cancel"),k.forEach(T),h=B(m),d=D(m,"DIV",{class:!0});var E=$(d);w=M(E,"Delete"),E.forEach(T),m.forEach(T),this.h()},h(){b(i,"class","button svelte-15m730s"),b(d,"class","button modal-delete svelte-15m730s"),b(c,"class","buttons modal-buttons svelte-15m730s")},m(p,f){C(p,e,f),y(e,t),y(e,o),y(e,l),C(p,n,f),C(p,c,f),y(c,i),y(i,u),y(c,h),y(c,d),y(d,w),v||(A=[K(i,"click",s[16]),K(d,"click",s[17])],v=!0)},p(p,f){f&4&&a!==(a=p[2].name+"")&&Ce(o,a)},d(p){p&&T(e),p&&T(n),p&&T(c),v=!1,Oe(A)}}}function fc(s){let e,t,a,o,l,n,c,i,u,h,d;const w=s[11].default,v=hr(w,s,s[19],null);let A=s[2]&&Gl(s);function p(m){s[18](m)}let f={$$slots:{default:[dc]},$$scope:{ctx:s}};return s[4]!==void 0&&(f.open=s[4]),c=new Eo({props:f}),ie.push(()=>re(c,"open",p)),{c(){e=S("div"),v&&v.c(),t=W(),A&&A.c(),n=W(),z(c.$$.fragment),this.h()},l(m){e=D(m,"DIV",{class:!0,draggable:!0});var k=$(e);v&&v.l(k),t=B(k),A&&A.l(k),k.forEach(T),n=B(m),Y(c.$$.fragment,m),this.h()},h(){b(e,"class","sidebar-entry svelte-15m730s"),b(e,"draggable",a=!!s[2]),Ee(e,"over",s[3]),Ee(e,"active",s[2]&&s[5]===s[2]),Ee(e,"in-folder",!!Je(s[2]))},m(m,k){C(m,e,k),v&&v.m(e,null),y(e,t),A&&A.m(e,null),C(m,n,k),j(c,m,k),u=!0,h||(d=[K(e,"dragstart",s[7]),K(e,"drop",Xs(ze(s[8]))),K(e,"dragover",ze(s[9])),K(e,"dragleave",s[15]),K(e,"click",s[12])],h=!0)},p(m,[k]){s=m,v&&v.p&&(!u||k&524288)&&pr(v,w,s,s[19],u?fr(w,s[19],k,null):dr(s[19]),null),s[2]?A?A.p(s,k):(A=Gl(s),A.c(),A.m(e,null)):A&&(A.d(1),A=null),(!u||k&4&&a!==(a=!!s[2]))&&b(e,"draggable",a),(!u||k&8)&&Ee(e,"over",s[3]),(!u||k&36)&&Ee(e,"active",s[2]&&s[5]===s[2]),(!u||k&4)&&Ee(e,"in-folder",!!Je(s[2]));const E={};k&524308&&(E.$$scope={dirty:k,ctx:s}),!i&&k&16&&(i=!0,E.open=s[4],ce(()=>i=!1)),c.$set(E)},i(m){u||(V(v,m),Ie(()=>{u&&(l&&l.end(1),o=to(e,s[10],{fn:xe,x:s[1]==="left"?-100:100,duration:500,delay:s[6]?0:s[0]}),o.start())}),V(c.$$.fragment,m),u=!0)},o(m){N(v,m),o&&o.invalidate(),l=ao(e,xe,{x:s[1]==="left"?-100:100,duration:500}),N(c.$$.fragment,m),u=!1},d(m){m&&T(e),v&&v.d(m),A&&A.d(),m&&l&&l.end(),m&&T(n),Z(c,m),h=!1,Oe(d)}}}function mc(s,e,t){let a,o;we(s,Ao,L=>t(5,a=L)),we(s,Js,L=>t(6,o=L));let{$$slots:l={},$$scope:n}=e,{delay:c=0}=e,{direction:i="left"}=e,{data:u=void 0}=e,h=!1,d=!1;const w=L=>{if(!u){L.preventDefault();return}Ke.set(u)},v=()=>{const L=Le(Ke);let G;u&&(G=Je(u));const ee=Je(L);if(ee&&ee.remove(L),G){G.add(L),t(3,h=!1),Tr();return}L instanceof Xe&&(Le(et)?vr(L):br(L),L.parent=void 0),t(3,h=!1)},A=()=>{const L=Le(Ke);u!==L&&t(3,h=!0)},p=(L,G)=>(Le(To)||(G.delay=0),G.fn(L,G));function f(L){Lr.call(this,s,L)}const m=()=>kr(u),k=()=>t(4,d=!0),E=()=>t(3,h=!1),U=()=>t(4,d=!1),x=()=>xr(u);function se(L){d=L,t(4,d)}return s.$$set=L=>{"delay"in L&&t(0,c=L.delay),"direction"in L&&t(1,i=L.direction),"data"in L&&t(2,u=L.data),"$$scope"in L&&t(19,n=L.$$scope)},[c,i,u,h,d,a,o,w,v,A,p,l,f,m,k,E,U,x,se,n]}class Me extends ue{constructor(e){super(),he(this,e,mc,fc,pe,{delay:0,direction:1,data:2})}}const zl=(s,{delay:e=0,duration:t=500})=>{const o=getComputedStyle(s).width.match(/([\d.]+)(.*)/);if(!o)return{delay:e,duration:t,css:n=>`max-width: unset; width: ${n*100}%;`};const l=Number.parseFloat(o[1]);return{delay:e,duration:t,css:n=>`max-width: unset; width: ${n*l}${o[2]}; min-width: unset;`}};function Yl(s,e,t){const a=s.slice();return a[16]=e[t],a[18]=t,a}function jl(s){let e,t=[],a=new Map,o,l,n=s[0].data;const c=i=>i[16].key;for(let i=0;i<n.length;i+=1){let u=Yl(s,n,i),h=c(u);a.set(h,t[i]=Zl(h,u))}return{c(){e=S("div");for(let i=0;i<t.length;i+=1)t[i].c();this.h()},l(i){e=D(i,"DIV",{class:!0});var u=$(e);for(let h=0;h<t.length;h+=1)t[h].l(u);u.forEach(T),this.h()},h(){b(e,"class","folder-content svelte-gwiyfq")},m(i,u){C(i,e,u);for(let h=0;h<t.length;h+=1)t[h]&&t[h].m(e,null);l=!0},p(i,u){u&1&&(n=i[0].data,$e(),t=bo(t,u,c,1,i,n,a,e,ko,Zl,null,Yl),Pe())},i(i){if(!l){for(let u=0;u<n.length;u+=1)V(t[u]);Ie(()=>{l&&(o||(o=Ye(e,Ms,{},!0)),o.run(1))}),l=!0}},o(i){for(let u=0;u<t.length;u+=1)N(t[u]);o||(o=Ye(e,Ms,{},!1)),o.run(0),l=!1},d(i){i&&T(e);for(let u=0;u<t.length;u+=1)t[u].d();i&&o&&o.end()}}}function gc(s){let e,t;function a(){return s[15](s[16])}return e=new Me({props:{data:s[16],$$slots:{default:[yc]},$$scope:{ctx:s}}}),e.$on("click",a),{c(){z(e.$$.fragment)},l(o){Y(e.$$.fragment,o)},m(o,l){j(e,o,l),t=!0},p(o,l){s=o;const n={};l&1&&(n.data=s[16]),l&524289&&(n.$$scope={dirty:l,ctx:s}),e.$set(n)},i(o){t||(V(e.$$.fragment,o),t=!0)},o(o){N(e.$$.fragment,o),t=!1},d(o){Z(e,o)}}}function wc(s){let e,t;return e=new Io({props:{folder:s[16]}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,o){const l={};o&1&&(l.folder=a[16]),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function yc(s){let e=s[16].name+"",t,a;return{c(){t=Q(e),a=W()},l(o){t=M(o,e),a=B(o)},m(o,l){C(o,t,l),C(o,a,l)},p(o,l){l&1&&e!==(e=o[16].name+"")&&Ce(t,e)},d(o){o&&T(t),o&&T(a)}}}function Zl(s,e){let t,a,o,l,n;const c=[wc,gc],i=[];function u(h,d){return h[16].isFolder?0:1}return a=u(e),o=i[a]=c[a](e),{key:s,first:null,c(){t=Se(),o.c(),l=Se(),this.h()},l(h){t=Se(),o.l(h),l=Se(),this.h()},h(){this.first=t},m(h,d){C(h,t,d),i[a].m(h,d),C(h,l,d),n=!0},p(h,d){e=h;let w=a;a=u(e),a===w?i[a].p(e,d):($e(),N(i[w],1,1,()=>{i[w]=null}),Pe(),o=i[a],o?o.p(e,d):(o=i[a]=c[a](e),o.c()),V(o,1),o.m(l.parentNode,l))},i(h){n||(V(o),n=!0)},o(h){N(o),n=!1},d(h){h&&T(t),i[a].d(h),h&&T(l)}}}function Tc(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A,p,f,m,k,E,U,x,se,L,G,ee,P=s[0].open&&jl(s);return{c(){e=S("div"),t=S("span"),a=Q("folder"),o=W(),l=S("span"),n=W(),c=S("div"),i=S("div"),u=S("span"),h=Q("add"),d=W(),w=S("div"),v=S("span"),A=Q("edit"),p=W(),f=S("div"),m=S("span"),k=Q("delete"),x=W(),P&&P.c(),se=Se(),this.h()},l(H){e=D(H,"DIV",{class:!0,draggable:!0});var te=$(e);t=D(te,"SPAN",{class:!0});var me=$(t);a=M(me,"folder"),me.forEach(T),o=B(te),l=D(te,"SPAN",{class:!0,contenteditable:!0}),$(l).forEach(T),n=B(te),c=D(te,"DIV",{class:!0});var de=$(c);i=D(de,"DIV",{class:!0,title:!0});var ye=$(i);u=D(ye,"SPAN",{class:!0});var q=$(u);h=M(q,"add"),q.forEach(T),ye.forEach(T),d=B(de),w=D(de,"DIV",{class:!0,title:!0});var Te=$(w);v=D(Te,"SPAN",{class:!0});var _e=$(v);A=M(_e,"edit"),_e.forEach(T),Te.forEach(T),p=B(de),f=D(de,"DIV",{class:!0,title:!0});var Re=$(f);m=D(Re,"SPAN",{class:!0});var ge=$(m);k=M(ge,"delete"),ge.forEach(T),Re.forEach(T),de.forEach(T),te.forEach(T),x=B(H),P&&P.l(H),se=Se(),this.h()},h(){b(t,"class","material-symbols-rounded folder-icon svelte-gwiyfq"),b(l,"class","name svelte-gwiyfq"),b(l,"contenteditable","false"),s[0].name===void 0&&Ie(()=>s[12].call(l)),b(u,"class","material-symbols-rounded"),b(i,"class","icon add svelte-gwiyfq"),b(i,"title","Add Folder"),b(v,"class","material-symbols-rounded"),b(w,"class","icon svelte-gwiyfq"),b(w,"title","Rename"),b(m,"class","material-symbols-rounded"),b(f,"class","icon delete svelte-gwiyfq"),b(f,"title","Delete Folder"),b(c,"class","buttons svelte-gwiyfq"),b(e,"class","folder svelte-gwiyfq"),b(e,"draggable","true"),Ee(e,"over",s[2])},m(H,te){C(H,e,te),y(e,t),y(t,a),y(e,o),y(e,l),s[11](l),s[0].name!==void 0&&(l.textContent=s[0].name),y(e,n),y(e,c),y(c,i),y(i,u),y(u,h),y(c,d),y(c,w),y(w,v),y(v,A),y(c,p),y(c,f),y(f,m),y(m,k),C(H,x,te),P&&P.m(H,te),C(H,se,te),L=!0,G||(ee=[K(l,"blur",function(){Fr(s[1].contentEditable="false")&&(s[1].contentEditable="false").apply(this,arguments)}),K(l,"input",s[12]),K(l,"keydown",s[5]),K(i,"click",s[7]),K(w,"click",s[4]),K(f,"click",s[6]),K(e,"dragstart",s[8]),K(e,"drop",Xs(ze(s[9]))),K(e,"dragover",ze(s[10])),K(e,"dragleave",s[13]),K(e,"click",s[14])],G=!0)},p(H,[te]){s=H,te&1&&s[0].name!==l.textContent&&(l.textContent=s[0].name),(!L||te&4)&&Ee(e,"over",s[2]),s[0].open?P?(P.p(s,te),te&1&&V(P,1)):(P=jl(s),P.c(),V(P,1),P.m(se.parentNode,se)):P&&($e(),N(P,1,1,()=>{P=null}),Pe())},i(H){L||(Ie(()=>{L&&(U&&U.end(1),E=to(e,Ms,{duration:s[3]?0:400}),E.start())}),V(P),L=!0)},o(H){E&&E.invalidate(),U=ao(e,Ms,{}),N(P),L=!1},d(H){H&&T(e),s[11](null),H&&U&&U.end(),H&&T(x),P&&P.d(H),H&&T(se),G=!1,Oe(ee)}}}function vc(s,e,t){let a;we(s,Js,E=>t(3,a=E));let{folder:o}=e,l,n=E=>{E&&E.stopPropagation(),t(1,l.contentEditable="true",l),l.focus(),setTimeout(()=>{const U=document.createRange();U.setStart(l,0),U.setEnd(l,1);const x=window.getSelection();x.removeAllRanges(),x.addRange(U)},1)};const c=E=>{E.key=="Enter"&&(E.preventDefault(),E.stopPropagation(),l.blur())},i=E=>{E.stopPropagation(),Hr(o)},u=E=>{E.stopPropagation(),o.createFolder(),t(0,o.open=!0,o),Tr()};let h=!1;const d=()=>{Ke.set(o)},w=()=>{t(2,h=!1);const E=Le(Ke);if(!E||o.data.includes(E))return;const U=Je(E);U&&U.remove(E),E instanceof Xe&&(Cr(E),E.parent=o),o.add(E)},v=()=>{o!==Le(Ke)&&t(2,h=!0)};function A(E){ie[E?"unshift":"push"](()=>{l=E,t(1,l)})}function p(){o.name=this.textContent,t(0,o)}const f=()=>t(2,h=!1),m=()=>t(0,o.open=!o.open,o),k=E=>Qs(`/${E.isClass?"class":"skill"}/${E.name}${E.isClass?"/edit":""}`);return s.$$set=E=>{"folder"in E&&t(0,o=E.folder)},[o,l,h,a,n,c,i,u,d,w,v,A,p,f,m,k]}class Io extends ue{constructor(e){super(),he(this,e,vc,Tc,pe,{folder:0})}}function Xl(s,e,t){const a=s.slice();return a[35]=e[t],a[31]=t,a}function Jl(s,e,t){const a=s.slice();return a[35]=e[t],a}function Ql(s,e,t){const a=s.slice();return a[29]=e[t],a[31]=t,a}function Ml(s,e,t){const a=s.slice();return a[32]=e[t],a}function bc(s){let e,t,a=[],o=new Map,l,n,c,i,u,h=s[8],d=[];for(let p=0;p<h.length;p+=1)d[p]=er(Jl(s,h,p));const w=p=>N(d[p],1,1,()=>{d[p]=null});let v=s[9].filter(s[18]);const A=p=>p[35].key;for(let p=0;p<v.length;p+=1){let f=Xl(s,v,p),m=A(f);o.set(m,a[p]=tr(m,f))}return n=new Me({props:{delay:200+100*(s[9].length+1),direction:"right",$$slots:{default:[Ac]},$$scope:{ctx:s}}}),{c(){e=S("div");for(let p=0;p<d.length;p+=1)d[p].c();t=W();for(let p=0;p<a.length;p+=1)a[p].c();l=W(),z(n.$$.fragment),this.h()},l(p){e=D(p,"DIV",{class:!0});var f=$(e);for(let m=0;m<d.length;m+=1)d[m].l(f);t=B(f);for(let m=0;m<a.length;m+=1)a[m].l(f);l=B(f),Y(n.$$.fragment,f),f.forEach(T),this.h()},h(){b(e,"class","items svelte-k5vek0")},m(p,f){C(p,e,f);for(let m=0;m<d.length;m+=1)d[m]&&d[m].m(e,null);y(e,t);for(let m=0;m<a.length;m+=1)a[m]&&a[m].m(e,null);y(e,l),j(n,e,null),u=!0},p(p,f){if(f[0]&256){h=p[8];let k;for(k=0;k<h.length;k+=1){const E=Jl(p,h,k);d[k]?(d[k].p(E,f),V(d[k],1)):(d[k]=er(E),d[k].c(),V(d[k],1),d[k].m(e,t))}for($e(),k=h.length;k<d.length;k+=1)w(k);Pe()}f[0]&514&&(v=p[9].filter(p[18]),$e(),a=bo(a,f,A,1,p,v,o,e,ko,tr,l,Xl),Pe());const m={};f[0]&512&&(m.delay=200+100*(p[9].length+1)),f[1]&256&&(m.$$scope={dirty:f,ctx:p}),n.$set(m)},i(p){if(!u){for(let f=0;f<h.length;f+=1)V(d[f]);for(let f=0;f<v.length;f+=1)V(a[f]);V(n.$$.fragment,p),Ie(()=>{u&&(i&&i.end(1),c=to(e,xe,{x:100}),c.start())}),u=!0}},o(p){d=d.filter(Boolean);for(let f=0;f<d.length;f+=1)N(d[f]);for(let f=0;f<a.length;f+=1)N(a[f]);N(n.$$.fragment,p),c&&c.invalidate(),i=ao(e,xe,{x:100}),u=!1},d(p){p&&T(e),_o(d,p);for(let f=0;f<a.length;f+=1)a[f].d();Z(n),p&&i&&i.end()}}}function kc(s){let e,t,a=[],o=new Map,l,n,c,i,u,h=s[6],d=[];for(let p=0;p<h.length;p+=1)d[p]=ar(Ml(s,h,p));const w=p=>N(d[p],1,1,()=>{d[p]=null});let v=s[7].filter(s[14]);const A=p=>p[29].key;for(let p=0;p<v.length;p+=1){let f=Ql(s,v,p),m=A(f);o.set(m,a[p]=sr(m,f))}return n=new Me({props:{delay:200+100*(s[7].length+1),$$slots:{default:[Sc]},$$scope:{ctx:s}}}),{c(){e=S("div");for(let p=0;p<d.length;p+=1)d[p].c();t=W();for(let p=0;p<a.length;p+=1)a[p].c();l=W(),z(n.$$.fragment),this.h()},l(p){e=D(p,"DIV",{class:!0});var f=$(e);for(let m=0;m<d.length;m+=1)d[m].l(f);t=B(f);for(let m=0;m<a.length;m+=1)a[m].l(f);l=B(f),Y(n.$$.fragment,f),f.forEach(T),this.h()},h(){b(e,"class","items svelte-k5vek0")},m(p,f){C(p,e,f);for(let m=0;m<d.length;m+=1)d[m]&&d[m].m(e,null);y(e,t);for(let m=0;m<a.length;m+=1)a[m]&&a[m].m(e,null);y(e,l),j(n,e,null),u=!0},p(p,f){if(f[0]&64){h=p[6];let k;for(k=0;k<h.length;k+=1){const E=Ml(p,h,k);d[k]?(d[k].p(E,f),V(d[k],1)):(d[k]=ar(E),d[k].c(),V(d[k],1),d[k].m(e,t))}for($e(),k=h.length;k<d.length;k+=1)w(k);Pe()}f[0]&129&&(v=p[7].filter(p[14]),$e(),a=bo(a,f,A,1,p,v,o,e,ko,sr,l,Ql),Pe());const m={};f[0]&128&&(m.delay=200+100*(p[7].length+1)),f[1]&256&&(m.$$scope={dirty:f,ctx:p}),n.$set(m)},i(p){if(!u){for(let f=0;f<h.length;f+=1)V(d[f]);for(let f=0;f<v.length;f+=1)V(a[f]);V(n.$$.fragment,p),Ie(()=>{u&&(i&&i.end(1),c=to(e,xe,{x:-100}),c.start())}),u=!0}},o(p){d=d.filter(Boolean);for(let f=0;f<d.length;f+=1)N(d[f]);for(let f=0;f<a.length;f+=1)N(a[f]);N(n.$$.fragment,p),c&&c.invalidate(),i=ao(e,xe,{x:-100}),u=!1},d(p){p&&T(e),_o(d,p);for(let f=0;f<a.length;f+=1)a[f].d();Z(n),p&&i&&i.end()}}}function er(s){let e,t;return e=new Io({props:{folder:s[35]}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,o){const l={};o[0]&256&&(l.folder=a[35]),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function _c(s){let e=s[35].name+"",t;return{c(){t=Q(e)},l(a){t=M(a,e)},m(a,o){C(a,t,o)},p(a,o){o[0]&514&&e!==(e=a[35].name+"")&&Ce(t,e)},d(a){a&&T(t)}}}function tr(s,e){let t,a,o;function l(){return e[19](e[35])}return a=new Me({props:{data:e[35],direction:"right",delay:200+100*e[31],$$slots:{default:[_c]},$$scope:{ctx:e}}}),a.$on("click",l),{key:s,first:null,c(){t=Se(),z(a.$$.fragment),this.h()},l(n){t=Se(),Y(a.$$.fragment,n),this.h()},h(){this.first=t},m(n,c){C(n,t,c),j(a,n,c),o=!0},p(n,c){e=n;const i={};c[0]&514&&(i.data=e[35]),c[0]&514&&(i.delay=200+100*e[31]),c[0]&514|c[1]&256&&(i.$$scope={dirty:c,ctx:e}),a.$set(i)},i(n){o||(V(a.$$.fragment,n),o=!0)},o(n){N(a.$$.fragment,n),o=!1},d(n){n&&T(t),Z(a,n)}}}function Ac(s){let e,t,a,o,l,n,c,i;return{c(){e=S("div"),t=S("span"),a=Q("New Skill"),o=W(),l=S("span"),n=Q("New Folder"),this.h()},l(u){e=D(u,"DIV",{class:!0});var h=$(e);t=D(h,"SPAN",{class:!0});var d=$(t);a=M(d,"New Skill"),d.forEach(T),o=B(h),l=D(h,"SPAN",{class:!0});var w=$(l);n=M(w,"New Folder"),w.forEach(T),h.forEach(T),this.h()},h(){b(t,"class","svelte-k5vek0"),b(l,"class","new-folder svelte-k5vek0"),b(e,"class","new svelte-k5vek0")},m(u,h){C(u,e,h),y(e,t),y(t,a),y(e,o),y(e,l),y(l,n),c||(i=[K(t,"click",s[20]),K(l,"click",s[21])],c=!0)},p:Fe,d(u){u&&T(e),c=!1,Oe(i)}}}function ar(s){let e,t;return e=new Io({props:{folder:s[32]}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,o){const l={};o[0]&64&&(l.folder=a[32]),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function Ec(s){let e=s[29].name+"",t;return{c(){t=Q(e)},l(a){t=M(a,e)},m(a,o){C(a,t,o)},p(a,o){o[0]&129&&e!==(e=a[29].name+"")&&Ce(t,e)},d(a){a&&T(t)}}}function sr(s,e){let t,a,o;function l(){return e[15](e[29])}return a=new Me({props:{data:e[29],delay:200+100*e[31],$$slots:{default:[Ec]},$$scope:{ctx:e}}}),a.$on("click",l),{key:s,first:null,c(){t=Se(),z(a.$$.fragment),this.h()},l(n){t=Se(),Y(a.$$.fragment,n),this.h()},h(){this.first=t},m(n,c){C(n,t,c),j(a,n,c),o=!0},p(n,c){e=n;const i={};c[0]&129&&(i.data=e[29]),c[0]&129&&(i.delay=200+100*e[31]),c[0]&129|c[1]&256&&(i.$$scope={dirty:c,ctx:e}),a.$set(i)},i(n){o||(V(a.$$.fragment,n),o=!0)},o(n){N(a.$$.fragment,n),o=!1},d(n){n&&T(t),Z(a,n)}}}function Sc(s){let e,t,a,o,l,n,c,i;return{c(){e=S("div"),t=S("span"),a=Q("New Class"),o=W(),l=S("span"),n=Q("New Folder"),this.h()},l(u){e=D(u,"DIV",{class:!0});var h=$(e);t=D(h,"SPAN",{class:!0});var d=$(t);a=M(d,"New Class"),d.forEach(T),o=B(h),l=D(h,"SPAN",{class:!0});var w=$(l);n=M(w,"New Folder"),w.forEach(T),h.forEach(T),this.h()},h(){b(t,"class","svelte-k5vek0"),b(l,"class","new-folder svelte-k5vek0"),b(e,"class","new svelte-k5vek0")},m(u,h){C(u,e,h),y(e,t),y(t,a),y(e,o),y(e,l),y(l,n),c||(i=[K(t,"click",s[16]),K(l,"click",s[17])],c=!0)},p:Fe,d(u){u&&T(e),c=!1,Oe(i)}}}function Dc(s){let e=!1,t=()=>{e=!1},a,o,l,n,c,i,u,h,d,w,v,A=`calc(${s[3]}px - 6rem + min(3.5rem, ${s[4]}px))`,p,f,m;Ie(s[11]),Ie(s[12]);function k(L){s[13](L)}let E={left:"Classes",right:"Skills",color:"#111",inline:!1};s[5]!==void 0&&(E.data=s[5]),n=new so({props:E}),ie.push(()=>re(n,"data",k));const U=[kc,bc],x=[];function se(L,G){return L[5]?0:1}return d=se(s),w=x[d]=U[d](s),{c(){o=S("div"),l=S("div"),z(n.$$.fragment),i=W(),u=S("hr"),h=W(),w.c(),this.h()},l(L){o=D(L,"DIV",{id:!0,class:!0});var G=$(o);l=D(G,"DIV",{class:!0});var ee=$(l);Y(n.$$.fragment,ee),i=B(ee),u=D(ee,"HR",{class:!0}),ee.forEach(T),h=B(G),w.l(G),G.forEach(T),this.h()},h(){b(u,"class","svelte-k5vek0"),b(l,"class","type-wrap svelte-k5vek0"),b(o,"id","sidebar"),b(o,"class","svelte-k5vek0"),Vl(o,"--height",A)},m(L,G){C(L,o,G),y(o,l),j(n,l,null),y(l,i),y(l,u),y(o,h),x[d].m(o,null),p=!0,f||(m=[K(window,"resize",s[11]),K(window,"scroll",()=>{e=!0,clearTimeout(a),a=setTimeout(t,100),s[12]()}),K(o,"introend",s[22]),K(o,"outroend",s[23]),Vr(jr.call(null,o)),K(o,"outclick",s[10])],f=!0)},p(L,G){G[0]&16&&!e&&(e=!0,clearTimeout(a),scrollTo(window.pageXOffset,L[4]),a=setTimeout(t,100));const ee={};!c&&G[0]&32&&(c=!0,ee.data=L[5],ce(()=>c=!1)),n.$set(ee);let P=d;d=se(L),d===P?x[d].p(L,G):($e(),N(x[P],1,1,()=>{x[P]=null}),Pe(),w=x[d],w?w.p(L,G):(w=x[d]=U[d](L),w.c()),V(w,1),w.m(o,null)),G[0]&24&&A!==(A=`calc(${L[3]}px - 6rem + min(3.5rem, ${L[4]}px))`)&&Vl(o,"--height",A)},i(L){p||(V(n.$$.fragment,L),V(w),Ie(()=>{p&&(v||(v=Ye(o,zl,{},!0)),v.run(1))}),p=!0)},o(L){N(n.$$.fragment,L),N(w),v||(v=Ye(o,zl,{},!1)),v.run(0),p=!1},d(L){L&&T(o),Z(n),x[d].d(),L&&v&&v.end(),f=!1,Oe(m)}}}function Ic(s,e,t){let a,o,l,n,c;we(s,et,q=>t(5,a=q)),we(s,fo,q=>t(6,o=q)),we(s,go,q=>t(7,l=q)),we(s,mo,q=>t(8,n=q)),we(s,wo,q=>t(9,c=q));let i=[],u,h,d=[],w=[],v,A,p;const f=(q,Te)=>{q instanceof Array&&q.forEach(_e=>f(_e,Te)),q instanceof Xe?f(q.data,Te):(q instanceof Qe||q instanceof He)&&Te.push(q)},m=q=>{Le(et)?(i=q||Le(fo),t(0,d=[]),f(i,d)):(i=q||Le(mo),t(1,w=[]),f(i,w))};mr(()=>{u=fo.subscribe(m),h=mo.subscribe(m)}),Rr(m),gr(()=>{u&&u(),h&&h()});const k=q=>{v<500&&(q.detail.stopPropagation(),Ur())};function E(){t(2,v=window.innerWidth),t(3,A=window.innerHeight)}function U(){t(4,p=window.pageYOffset)}function x(q){a=q,et.set(a)}return[d,w,v,A,p,a,o,l,n,c,k,E,U,x,q=>!d.includes(q),q=>{yo.set(!1),Qs(`/class/${q.name}/edit`)},()=>Wr(),()=>vr(new Xe),q=>!w.includes(q),q=>{yo.set(!1),Qs(`/skill/${q.name}`)},()=>Br(),()=>br(new Xe),()=>Js.set(!0),()=>Js.set(!1)]}class $c extends ue{constructor(e){super(),he(this,e,Ic,Dc,pe,{},null,[-1,-1])}}function or(s){let e,t,a=s[0]==="class"?"Class":"Skill",o,l,n,c;return{c(){e=S("div"),t=Q("Share "),o=Q(a),this.h()},l(i){e=D(i,"DIV",{class:!0,title:!0});var u=$(e);t=M(u,"Share "),o=M(u,a),u.forEach(T),this.h()},h(){b(e,"class","chip share svelte-yx67gl"),b(e,"title",l="Share "+(s[0]==="class"?"Class":"Skill"))},m(i,u){C(i,e,u),y(e,t),y(e,o),n||(c=K(e,"click",s[2]),n=!0)},p(i,u){u&1&&a!==(a=i[0]==="class"?"Class":"Skill")&&Ce(o,a),u&1&&l!==(l="Share "+(i[0]==="class"?"Class":"Skill"))&&b(e,"title",l)},d(i){i&&T(e),n=!1,c()}}}function nr(s){let e,t;return e=new $c({}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function Pc(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A,p,f,m=s[0]&&or(s),k=s[1]&&nr();return{c(){e=S("div"),t=S("nav"),a=S("div"),o=S("span"),l=Q("menu"),n=W(),c=S("div"),i=W(),u=S("div"),h=S("div"),d=Q("Import"),w=W(),m&&m.c(),v=W(),k&&k.c(),this.h()},l(E){e=D(E,"DIV",{class:!0});var U=$(e);t=D(U,"NAV",{class:!0});var x=$(t);a=D(x,"DIV",{class:!0});var se=$(a);o=D(se,"SPAN",{class:!0});var L=$(o);l=M(L,"menu"),L.forEach(T),se.forEach(T),n=B(x),c=D(x,"DIV",{}),$(c).forEach(T),i=B(x),u=D(x,"DIV",{class:!0});var G=$(u);h=D(G,"DIV",{class:!0,title:!0});var ee=$(h);d=M(ee,"Import"),ee.forEach(T),w=B(G),m&&m.l(G),G.forEach(T),v=B(x),k&&k.l(x),x.forEach(T),U.forEach(T),this.h()},h(){b(o,"class","material-symbols-rounded"),b(a,"class","chip hamburger svelte-yx67gl"),b(h,"class","chip import svelte-yx67gl"),b(h,"title","Import Data"),b(u,"class","transfer svelte-yx67gl"),b(t,"class","svelte-yx67gl"),b(e,"class","nav-wrap svelte-yx67gl")},m(E,U){C(E,e,U),y(e,t),y(t,a),y(a,o),y(o,l),y(t,n),y(t,c),y(t,i),y(t,u),y(u,h),y(h,d),y(u,w),m&&m.m(u,null),y(t,v),k&&k.m(t,null),A=!0,p||(f=[K(a,"click",s[4]),K(h,"click",s[3])],p=!0)},p(E,[U]){E[0]?m?m.p(E,U):(m=or(E),m.c(),m.m(u,null)):m&&(m.d(1),m=null),E[1]?k?U&2&&V(k,1):(k=nr(),k.c(),V(k,1),k.m(t,null)):k&&($e(),N(k,1,1,()=>{k=null}),Pe())},i(E){A||(V(k),A=!0)},o(E){N(k),A=!1},d(E){E&&T(e),m&&m.d(),k&&k.d(),p=!1,Oe(f)}}}function Oc(s,e,t){let a,o;return we(s,Gr,i=>t(0,a=i)),we(s,yo,i=>t(1,o=i)),[a,o,()=>{let i=Le(Ao);if(!i)return;let u=i.serializeYaml().toString();lc(u).then(h=>{var d;(d=navigator==null?void 0:navigator.clipboard)==null||d.writeText(h),window.open(h)}).catch(h=>console.error(h))},()=>{wr(!0)},i=>{i.stopPropagation(),Kr()}]}class Lc extends ue{constructor(e){super(),he(this,e,Oc,Pc,pe,{})}}function Fc(s){let e,t,a;return{c(){e=ho("svg"),t=ho("g"),a=ho("path"),this.h()},l(o){e=po(o,"svg",{viewBox:!0,class:!0});var l=$(e);t=po(l,"g",{fill:!0});var n=$(t);a=po(n,"path",{d:!0}),$(a).forEach(T),n.forEach(T),l.forEach(T),this.h()},h(){b(a,"d","M26.0015 6.9529C24.0021 6.03845 21.8787 5.37198 19.6623 5C19.3833 5.48048 19.0733 6.13144 18.8563 6.64292C16.4989 6.30193 14.1585 6.30193 11.8336 6.64292C11.6166 6.13144 11.2911 5.48048 11.0276 5C8.79575 5.37198 6.67235 6.03845 4.6869 6.9529C0.672601 12.8736 -0.41235 18.6548 0.130124 24.3585C2.79599 26.2959 5.36889 27.4739 7.89682 28.2489C8.51679 27.4119 9.07477 26.5129 9.55525 25.5675C8.64079 25.2265 7.77283 24.808 6.93587 24.312C7.15286 24.1571 7.36986 23.9866 7.57135 23.8161C12.6241 26.1255 18.0969 26.1255 23.0876 23.8161C23.3046 23.9866 23.5061 24.1571 23.7231 24.312C22.8861 24.808 22.0182 25.2265 21.1037 25.5675C21.5842 26.5129 22.1422 27.4119 22.7621 28.2489C25.2885 27.4739 27.8769 26.2959 30.5288 24.3585C31.1952 17.7559 29.4733 12.0212 26.0015 6.9529ZM10.2527 20.8402C8.73376 20.8402 7.49382 19.4608 7.49382 17.7714C7.49382 16.082 8.70276 14.7025 10.2527 14.7025C11.7871 14.7025 13.0425 16.082 13.0115 17.7714C13.0115 19.4608 11.7871 20.8402 10.2527 20.8402ZM20.4373 20.8402C18.9183 20.8402 17.6768 19.4608 17.6768 17.7714C17.6768 16.082 18.8873 14.7025 20.4373 14.7025C21.9717 14.7025 23.2271 16.082 23.1961 17.7714C23.1961 19.4608 21.9872 20.8402 20.4373 20.8402Z"),b(t,"fill","currentColor"),b(e,"viewBox","0 0 30 34"),b(e,"class","logo-3oeRIY svelte-evyltu")},m(o,l){C(o,e,l),y(e,t),y(t,a)},p:Fe,i:Fe,o:Fe,d(o){o&&T(e)}}}class Vc extends ue{constructor(e){super(),he(this,e,null,Fc,pe,{})}}function Rc(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A,p,f,m,k,E,U,x,se,L,G,ee,P;return d=new Vc({}),{c(){e=S("div"),t=S("div"),a=S("h1"),o=Q("ProSkillAPI"),l=W(),n=S("h2"),c=Q("Dynamic Editor"),i=W(),u=S("div"),h=S("a"),z(d.$$.fragment),w=W(),v=S("a"),A=S("img"),f=W(),m=S("a"),k=S("img"),U=W(),x=S("a"),se=S("span"),L=Q("help"),this.h()},l(H){e=D(H,"DIV",{id:!0,class:!0});var te=$(e);t=D(te,"DIV",{class:!0});var me=$(t);a=D(me,"H1",{class:!0});var de=$(a);o=M(de,"ProSkillAPI"),de.forEach(T),l=B(me),n=D(me,"H2",{class:!0});var ye=$(n);c=M(ye,"Dynamic Editor"),ye.forEach(T),me.forEach(T),i=B(te),u=D(te,"DIV",{class:!0});var q=$(u);h=D(q,"A",{class:!0,href:!0,title:!0});var Te=$(h);Y(d.$$.fragment,Te),Te.forEach(T),w=B(q),v=D(q,"A",{class:!0,href:!0,title:!0});var _e=$(v);A=D(_e,"IMG",{src:!0,class:!0}),_e.forEach(T),f=B(q),m=D(q,"A",{class:!0,href:!0,title:!0});var Re=$(m);k=D(Re,"IMG",{src:!0,class:!0}),Re.forEach(T),U=B(q),x=D(q,"A",{class:!0,href:!0,title:!0});var ge=$(x);se=D(ge,"SPAN",{class:!0});var le=$(se);L=M(le,"help"),le.forEach(T),ge.forEach(T),q.forEach(T),te.forEach(T),this.h()},h(){b(a,"class","accent svelte-n9c92r"),b(n,"class","svelte-n9c92r"),b(t,"class","home svelte-n9c92r"),b(h,"class","social discord svelte-n9c92r"),b(h,"href","https://discord.gg/6UzkTe6RvW"),b(h,"title","Join our Discord"),Rl(A.src,p="/github-mark-white.svg")||b(A,"src",p),b(A,"class","svelte-n9c92r"),b(v,"class","social github svelte-n9c92r"),b(v,"href","https://github.com/promcteam/proskillapi"),b(v,"title","Check out our GitHub"),Rl(k.src,E="/spigot.png")||b(k,"src",E),b(k,"class","svelte-n9c92r"),b(m,"class","social spigot svelte-n9c92r"),b(m,"href","https://www.spigotmc.org/resources/proskillapi-create-custom-races-classes-skills-spells-with-an-easy-online-editor.91913/"),b(m,"title","Check out our resource on Spigot"),b(se,"class","material-symbols-rounded"),b(x,"class","social wiki svelte-n9c92r"),b(x,"href","https://promcteam.com/wiki/index.php?title=Proskillapi:Proskillapi"),b(x,"title","Wiki"),b(u,"class","socials svelte-n9c92r"),b(e,"id","header"),b(e,"class","svelte-n9c92r")},m(H,te){C(H,e,te),y(e,t),y(t,a),y(a,o),y(t,l),y(t,n),y(n,c),y(e,i),y(e,u),y(u,h),j(d,h,null),y(u,w),y(u,v),y(v,A),y(u,f),y(u,m),y(m,k),y(u,U),y(u,x),y(x,se),y(se,L),G=!0,ee||(P=K(t,"click",s[0]),ee=!0)},p:Fe,i(H){G||(V(d.$$.fragment,H),G=!0)},o(H){N(d.$$.fragment,H),G=!1},d(H){H&&T(e),Z(d),ee=!1,P()}}}function Nc(s){return[()=>Qs("/")]}class qc extends ue{constructor(e){super(),he(this,e,Nc,Rc,pe,{})}}function xc(s){let e,t,a;function o(n){s[1](n)}let l={any:!0,multiple:!0};return s[0].material!==void 0&&(l.selected=s[0].material),e=new _r({props:l}),ie.push(()=>re(e,"selected",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&1&&(t=!0,i.selected=n[0].material,ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function Hc(s){let e,t,a,o,l;e=new be({props:{label:"Material",tooltip:s[0].materialTooltip,$$slots:{default:[xc]},$$scope:{ctx:s}}});function n(i){s[2](i)}let c={type:"number",intMode:!0,label:"Data",tooltip:s[0].dataTooltip};return s[0].data!==void 0&&(c.value=s[0].data),a=new be({props:c}),ie.push(()=>re(a,"value",n)),{c(){z(e.$$.fragment),t=W(),z(a.$$.fragment)},l(i){Y(e.$$.fragment,i),t=B(i),Y(a.$$.fragment,i)},m(i,u){j(e,i,u),C(i,t,u),j(a,i,u),l=!0},p(i,[u]){const h={};u&1&&(h.tooltip=i[0].materialTooltip),u&17&&(h.$$scope={dirty:u,ctx:i}),e.$set(h);const d={};u&1&&(d.tooltip=i[0].dataTooltip),!o&&u&1&&(o=!0,d.value=i[0].data,ce(()=>o=!1)),a.$set(d)},i(i){l||(V(e.$$.fragment,i),V(a.$$.fragment,i),l=!0)},o(i){N(e.$$.fragment,i),N(a.$$.fragment,i),l=!1},d(i){Z(e,i),i&&T(t),Z(a,i)}}}function Cc(s,e,t){let{data:a}=e;const o=De();function l(c){s.$$.not_equal(a.material,c)&&(a.material=c,t(0,a))}function n(c){s.$$.not_equal(a.data,c)&&(a.data=c,t(0,a))}return s.$$set=c=>{"data"in c&&t(0,a=c.data)},s.$$.update=()=>{s.$$.dirty&1&&a&&o("save")},[a,l,n]}class Wc extends ue{constructor(e){super(),he(this,e,Cc,Hc,pe,{data:0})}}class Ae{constructor(){r(this,"targetKey");r(this,"targetValue",[]);r(this,"requireValue",(e,t)=>(this.targetKey=e,this.targetValue=t,this));r(this,"meetsRequirements",e=>this.targetKey?this.targetValue.includes(e.getRawData().get(this.targetKey)):!0)}}class oo extends Ae{constructor(t,a){super();r(this,"component",Wc);r(this,"data",{material:["Any"],data:-1,materialTooltip:"",dataTooltip:""});r(this,"setTooltip",()=>{throw new Error("Block Select requires tooltips be set in the constructor")});r(this,"clone",()=>{const t=new oo;return t.data=JSON.parse(JSON.stringify(this.data)),t});r(this,"getData",()=>{const t={};return t.material=this.data.material,t.data=this.data.data??-1,t});r(this,"deserialize",t=>{this.data.material=t.get("material",["Any"]),this.data.data=t.get("data",-1)});this.data.materialTooltip=t||"",this.data.dataTooltip=a||""}}function Bc(s){let e,t,a,o,l;function n(h){s[3](h)}function c(h){s[4](h)}function i(h){s[5](h)}let u={};return s[0].selected!==void 0&&(u.selected=s[0].selected),s[0].value!==void 0&&(u.data=s[0].value),s[0].multiple!==void 0&&(u.multiple=s[0].multiple),e=new So({props:u}),ie.push(()=>re(e,"selected",n)),ie.push(()=>re(e,"data",c)),ie.push(()=>re(e,"multiple",i)),{c(){z(e.$$.fragment)},l(h){Y(e.$$.fragment,h)},m(h,d){j(e,h,d),l=!0},p(h,d){const w={};!t&&d&1&&(t=!0,w.selected=h[0].selected,ce(()=>t=!1)),!a&&d&1&&(a=!0,w.data=h[0].value,ce(()=>a=!1)),!o&&d&1&&(o=!0,w.multiple=h[0].multiple,ce(()=>o=!1)),e.$set(w)},i(h){l||(V(e.$$.fragment,h),l=!0)},o(h){N(e.$$.fragment,h),l=!1},d(h){Z(e,h)}}}function Uc(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[Bc]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&129&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function Gc(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(h){s.$$.not_equal(a.selected,h)&&(a.selected=h,t(0,a))}function i(h){s.$$.not_equal(a.value,h)&&(a.value=h,t(0,a))}function u(h){s.$$.not_equal(a.multiple,h)&&(a.multiple=h,t(0,a))}return s.$$set=h=>{"data"in h&&t(0,a=h.data),"name"in h&&t(1,o=h.name),"tooltip"in h&&t(2,l=h.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&n("save")},[a,o,l,c,i,u]}class Kc extends ue{constructor(e){super(),he(this,e,Gc,Uc,pe,{data:0,name:1,tooltip:2})}}class _ extends Ae{constructor(t,a,o,l,n=!1){super();r(this,"component",Kc);r(this,"dataSource");r(this,"data",{selected:"",value:[],multiple:!1});r(this,"name","");r(this,"key","");r(this,"tooltip");r(this,"init",()=>{this.dataSource&&(this.data.value=this.dataSource()),!this.data.selected&&this.data.value.length>0&&!this.data.multiple&&(this.data.selected=this.data.value[0])});r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new _(this.name,this.key,[...this.data.value],this.data.selected));r(this,"getData",()=>{const t={};return t[this.key]=this.data.selected,t});r(this,"deserialize",t=>this.data.selected=t.get(this.key));this.name=t,this.key=a,typeof o=="function"?this.dataSource=o:this.data.value=o,n&&(this.data.selected=[]),l&&(this.data.selected=l),this.data.multiple=n}}function zc(s){let e,t,a,o;function l(i){s[3](i)}function n(i){s[4](i)}let c={};return s[0].material!==void 0&&(c.selected=s[0].material),s[0].any!==void 0&&(c.any=s[0].any),e=new _r({props:c}),ie.push(()=>re(e,"selected",l)),ie.push(()=>re(e,"any",n)),{c(){z(e.$$.fragment)},l(i){Y(e.$$.fragment,i)},m(i,u){j(e,i,u),o=!0},p(i,u){const h={};!t&&u&1&&(t=!0,h.selected=i[0].material,ce(()=>t=!1)),!a&&u&1&&(a=!0,h.any=i[0].any,ce(()=>a=!1)),e.$set(h)},i(i){o||(V(e.$$.fragment,i),o=!0)},o(i){N(e.$$.fragment,i),o=!1},d(i){Z(e,i)}}}function Yc(s){let e,t;return e=new be({props:{label:"Material",tooltip:s[1],$$slots:{default:[zc]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.tooltip=a[1]),o&65&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function jc(s,e,t){let{data:a}=e,{any:o}=e,{tooltip:l=void 0}=e;const n=De();function c(u){s.$$.not_equal(a.material,u)&&(a.material=u,t(0,a))}function i(u){s.$$.not_equal(a.any,u)&&(a.any=u,t(0,a))}return s.$$set=u=>{"data"in u&&t(0,a=u.data),"any"in u&&t(2,o=u.any),"tooltip"in u&&t(1,l=u.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&n("save")},[a,l,o,c,i]}class Zc extends ue{constructor(e){super(),he(this,e,jc,Yc,pe,{data:0,any:2,tooltip:1})}}class We extends Ae{constructor(t=!0,a){super();r(this,"component",Zc);r(this,"data",{material:"Dirt",any:!1});r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>{const t=new We;return t.data.material=this.data.material,t.data.any=this.data.any,t});r(this,"getData",()=>{const t={};return t.material=this.data.material,t});r(this,"deserialize",t=>this.data.material=t.get("material","Dirt"));this.data.any=t,a&&(this.data.material=a)}}function Xc(s){let e,t,a;function o(n){s[4](n)}let l={};return s[0]!==void 0&&(l.data=s[0]),e=new so({props:l}),ie.push(()=>re(e,"data",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&1&&(t=!0,i.data=n[0],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function Jc(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[Xc]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&65&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function Qc(s,e,t){let{data:a}=e,{any:o}=e,{name:l=""}=e,{tooltip:n=void 0}=e;const c=De();function i(u){a=u,t(0,a)}return s.$$set=u=>{"data"in u&&t(0,a=u.data),"any"in u&&t(3,o=u.any),"name"in u&&t(1,l=u.name),"tooltip"in u&&t(2,n=u.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&c("save")},[a,l,n,o,i]}class Mc extends ue{constructor(e){super(),he(this,e,Qc,Jc,pe,{data:0,any:3,name:1,tooltip:2})}}class F extends Ae{constructor(t,a,o=!1){super();r(this,"component",Mc);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new F(this.name,this.key,this.data));r(this,"getData",()=>{const t={};return t[this.key]=!!this.data,t});r(this,"deserialize",t=>this.data=t.get(this.key,!1));this.name=t,this.key=a,this.data=o}}function eu(s){let e,t,a;function o(n){s[3](n)}let l={label:s[1],tooltip:s[2],type:"number",placeholder:"0"};return s[0]!==void 0&&(l.value=s[0]),e=new be({props:l}),ie.push(()=>re(e,"value",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,[c]){const i={};c&2&&(i.label=n[1]),c&4&&(i.tooltip=n[2]),!t&&c&1&&(t=!0,i.value=n[0],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function tu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(i){a=i,t(0,a)}return s.$$set=i=>{"data"in i&&t(0,a=i.data),"name"in i&&t(1,o=i.name),"tooltip"in i&&t(2,l=i.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&n("save")},[a,o,l,c]}class au extends ue{constructor(e){super(),he(this,e,tu,eu,pe,{data:0,name:1,tooltip:2})}}class X extends Ae{constructor(t,a,o=0){super();r(this,"component",au);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new X(this.name,this.key,this.data));r(this,"getData",()=>{const t={};return t[this.key]=this.data||0,t});r(this,"deserialize",t=>this.data=t.get(this.key,0));this.name=t,this.key=a,this.data=o}}function su(s){let e,t,a;function o(n){s[3](n)}let l={};return s[0].value!==void 0&&(l.value=s[0].value),e=new Zr({props:l}),ie.push(()=>re(e,"value",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&1&&(t=!0,i.value=n[0].value,ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function ou(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[su]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&33&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function nu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(i){s.$$.not_equal(a.value,i)&&(a.value=i,t(0,a))}return s.$$set=i=>{"data"in i&&t(0,a=i.data),"name"in i&&t(1,o=i.name),"tooltip"in i&&t(2,l=i.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&a&&n("save")},[a,o,l,c]}class iu extends ue{constructor(e){super(),he(this,e,nu,ou,pe,{data:0,name:1,tooltip:2})}}class Ve extends Ae{constructor(t,a,o){super();r(this,"component",iu);r(this,"data",{value:[]});r(this,"name","");r(this,"key","");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new Ve(this.name,this.key,[...this.data.value]));r(this,"getData",()=>{const t={};return t[this.key]=this.data.value,t});r(this,"deserialize",t=>{this.data.value=t.get(this.key)});this.name=t,this.key=a,this.data.value=o||[]}}function lu(s){let e,t,a;function o(n){s[3](n)}let l={};return s[0]!==void 0&&(l.value=s[0]),e=new Xr({props:l}),ie.push(()=>re(e,"value",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&1&&(t=!0,i.value=n[0],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function ru(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[lu]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&33&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function cu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(i){a=i,t(0,a)}return s.$$set=i=>{"data"in i&&t(0,a=i.data),"name"in i&&t(1,o=i.name),"tooltip"in i&&t(2,l=i.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&n("save")},[a,o,l,c]}class uu extends ue{constructor(e){super(),he(this,e,cu,ru,pe,{data:0,name:1,tooltip:2})}}class g extends Ae{constructor(t,a,o=0,l=0){super();r(this,"component",uu);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new g(this.name,this.key,this.data.base,this.data.scale));r(this,"getData",()=>{const t={};return t[this.key+"-base"]=this.data.base||0,t[this.key+"-scale"]=this.data.scale||0,t});r(this,"deserialize",t=>{this.data.base=t.get(this.key+"-base",0),this.data.scale=t.get(this.key+"-scale",0)});this.name=t,this.key=a,this.data=new zr(t,o,l)}}function hu(s){let e,t,a,o;return{c(){e=S("div"),t=Q(s[0]),a=W(),o=S("hr"),this.h()},l(l){e=D(l,"DIV",{class:!0});var n=$(e);t=M(n,s[0]),a=B(n),o=D(n,"HR",{class:!0}),n.forEach(T),this.h()},h(){b(o,"class","svelte-x2dop6"),b(e,"class","svelte-x2dop6")},m(l,n){C(l,e,n),y(e,t),y(e,a),y(e,o)},p(l,[n]){n&1&&Ce(t,l[0])},i:Fe,o:Fe,d(l){l&&T(e)}}}function pu(s,e,t){let{data:a}=e;return s.$$set=o=>{"data"in o&&t(0,a=o.data)},s.$$.update=()=>{s.$$.dirty&1&&console.log(a)},[a]}class du extends ue{constructor(e){super(),he(this,e,pu,hu,pe,{data:0})}}class ke extends Ae{constructor(t){super();r(this,"component",du);r(this,"data");r(this,"setTooltip",t=>this);r(this,"clone",()=>new ke(this.data));r(this,"getData",()=>({}));r(this,"deserialize",t=>{});this.data=t}}function fu(s){let e,t,a;function o(n){s[3](n)}let l={label:s[1],tooltip:s[2]};return s[0]!==void 0&&(l.value=s[0]),e=new be({props:l}),ie.push(()=>re(e,"value",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,[c]){const i={};c&2&&(i.label=n[1]),c&4&&(i.tooltip=n[2]),!t&&c&1&&(t=!0,i.value=n[0],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function mu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(i){a=i,t(0,a)}return s.$$set=i=>{"data"in i&&t(0,a=i.data),"name"in i&&t(1,o=i.name),"tooltip"in i&&t(2,l=i.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&n("save")},[a,o,l,c]}class gu extends ue{constructor(e){super(),he(this,e,mu,fu,pe,{data:0,name:1,tooltip:2})}}class R extends Ae{constructor(t,a,o=""){super();r(this,"component",gu);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new R(this.name,this.key,this.data));r(this,"getData",()=>{const t={};return t[this.key]=this.data||"",t});r(this,"deserialize",t=>this.data=t.get(this.key,""));this.name=t,this.key=a,this.data=o}}function wu(s){let e,t,a,o;function l(i){s[6](i)}function n(i){s[7](i)}let c={display:Tu,multiple:s[3]};return s[4]!==void 0&&(c.data=s[4]),s[0]!==void 0&&(c.selected=s[0]),e=new So({props:c}),ie.push(()=>re(e,"data",l)),ie.push(()=>re(e,"selected",n)),{c(){z(e.$$.fragment)},l(i){Y(e.$$.fragment,i)},m(i,u){j(e,i,u),o=!0},p(i,u){const h={};u&8&&(h.multiple=i[3]),!t&&u&16&&(t=!0,h.data=i[4],ce(()=>t=!1)),!a&&u&1&&(a=!0,h.selected=i[0],ce(()=>a=!1)),e.$set(h)},i(i){o||(V(e.$$.fragment,i),o=!0)},o(i){N(e.$$.fragment,i),o=!1},d(i){Z(e,i)}}}function yu(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[wu]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&537&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}const Tu=s=>s.name;function vu(s,e,t){let a;we(s,go,w=>t(4,a=w));let{data:o=[]}=e,{any:l}=e,{name:n=""}=e,{tooltip:c=void 0}=e,{multiple:i=!0}=e;const u=De();function h(w){a=w,go.set(a)}function d(w){o=w,t(0,o)}return s.$$set=w=>{"data"in w&&t(0,o=w.data),"any"in w&&t(5,l=w.any),"name"in w&&t(1,n=w.name),"tooltip"in w&&t(2,c=w.tooltip),"multiple"in w&&t(3,i=w.multiple)},s.$$.update=()=>{if(s.$$.dirty&1){if(o instanceof Array)t(0,o=o.map(w=>{if(w instanceof Qe)return w;const v=ql(w);if(v)return v})),u("save");else if(o&&!(o instanceof Qe)){const w=ql(o);w&&t(0,o=w)}}},[o,n,c,i,a,l,h,d]}class bu extends ue{constructor(e){super(),he(this,e,vu,yu,pe,{data:0,any:5,name:1,tooltip:2,multiple:3})}}class $o extends Ae{constructor(t,a,o=!0){super();r(this,"component",bu);r(this,"name");r(this,"key");r(this,"data",[]);r(this,"tooltip");r(this,"multiple",!0);r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>{const t=new $o(this.name,this.key);return t.data=this.data,t});r(this,"getData",()=>{const t={};return this.data instanceof Array?t[this.key]=this.data.map(a=>a instanceof Qe?a.name:a):t[this.key]=this.data instanceof Qe?this.data.name:this.data,t});r(this,"deserialize",t=>{this.data=t.get(this.key,this.multiple?[]:"")});this.name=t,this.key=a,this.multiple=o}}function ku(s){let e,t,a,o;function l(i){s[6](i)}function n(i){s[7](i)}let c={display:Au,multiple:s[3]};return s[4]!==void 0&&(c.data=s[4]),s[0]!==void 0&&(c.selected=s[0]),e=new So({props:c}),ie.push(()=>re(e,"data",l)),ie.push(()=>re(e,"selected",n)),{c(){z(e.$$.fragment)},l(i){Y(e.$$.fragment,i)},m(i,u){j(e,i,u),o=!0},p(i,u){const h={};u&8&&(h.multiple=i[3]),!t&&u&16&&(t=!0,h.data=i[4],ce(()=>t=!1)),!a&&u&1&&(a=!0,h.selected=i[0],ce(()=>a=!1)),e.$set(h)},i(i){o||(V(e.$$.fragment,i),o=!0)},o(i){N(e.$$.fragment,i),o=!1},d(i){Z(e,i)}}}function _u(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[ku]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&537&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}const Au=s=>s.name||"";function Eu(s,e,t){let a;we(s,wo,w=>t(4,a=w));let{data:o=[]}=e,{any:l}=e,{name:n=""}=e,{tooltip:c=void 0}=e,{multiple:i=!0}=e;const u=De();function h(w){a=w,wo.set(a)}function d(w){o=w,t(0,o),t(3,i)}return s.$$set=w=>{"data"in w&&t(0,o=w.data),"any"in w&&t(5,l=w.any),"name"in w&&t(1,n=w.name),"tooltip"in w&&t(2,c=w.tooltip),"multiple"in w&&t(3,i=w.multiple)},s.$$.update=()=>{if(s.$$.dirty&9&&!i&&o.length===0&&t(0,o=""),s.$$.dirty&1){if(o instanceof Array)t(0,o=o.map(w=>{if(w instanceof He)return w;const v=xl(w);if(v)return v})),u("save");else if(o&&!(o instanceof He)){const w=xl(o);w&&t(0,o=w)}}},[o,n,c,i,a,l,h,d]}class Su extends ue{constructor(e){super(),he(this,e,Eu,_u,pe,{data:0,any:5,name:1,tooltip:2,multiple:3})}}class no extends Ae{constructor(t,a,o=!0){super();r(this,"component",Su);r(this,"name");r(this,"key");r(this,"data",[]);r(this,"tooltip");r(this,"multiple",!0);r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>{const t=new no(this.name,this.key);return t.data=this.data,t});r(this,"getData",()=>{const t={};return this.data instanceof Array?t[this.key]=this.data.map(a=>a instanceof He?a.name:a):t[this.key]=this.data instanceof He?this.data.name:this.data,t});r(this,"deserialize",t=>{this.data=t.get(this.key,this.multiple?[]:"")});this.name=t,this.key=a,this.multiple=o}}function Du(s){let e,t,a;function o(n){s[3](n)}let l={label:s[1],tooltip:s[2],type:"number",intMode:!0,placeholder:"0"};return s[0]!==void 0&&(l.value=s[0]),e=new be({props:l}),ie.push(()=>re(e,"value",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,[c]){const i={};c&2&&(i.label=n[1]),c&4&&(i.tooltip=n[2]),!t&&c&1&&(t=!0,i.value=n[0],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function Iu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(i){a=i,t(0,a)}return s.$$set=i=>{"data"in i&&t(0,a=i.data),"name"in i&&t(1,o=i.name),"tooltip"in i&&t(2,l=i.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&n("save")},[a,o,l,c]}class $u extends ue{constructor(e){super(),he(this,e,Iu,Du,pe,{data:0,name:1,tooltip:2})}}class oe extends Ae{constructor(t,a,o=0){super();r(this,"component",$u);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new oe(this.name,this.key,this.data));r(this,"getData",()=>{const t={};return t[this.key]=this.data||0,t});r(this,"deserialize",t=>this.data=t.get(this.key,0));this.name=t,this.key=a,this.data=o}}function Pu(s){let e,t,a,o,l,n;return{c(){e=S("div"),t=S("input"),a=W(),o=S("input"),this.h()},l(c){e=D(c,"DIV",{class:!0});var i=$(e);t=D(i,"INPUT",{class:!0}),a=B(i),o=D(i,"INPUT",{type:!0,class:!0}),i.forEach(T),this.h()},h(){b(t,"class","text svelte-1ncbyp2"),b(o,"type","color"),b(o,"class","svelte-1ncbyp2"),b(e,"class","wrap svelte-1ncbyp2")},m(c,i){C(c,e,i),y(e,t),Ge(t,s[0]),y(e,a),y(e,o),Ge(o,s[0]),l||(n=[K(t,"input",s[3]),K(o,"input",s[4])],l=!0)},p(c,i){i&1&&t.value!==c[0]&&Ge(t,c[0]),i&1&&Ge(o,c[0])},d(c){c&&T(e),l=!1,Oe(n)}}}function Ou(s){let e,t;return e=new be({props:{label:s[1],tooltip:s[2],$$slots:{default:[Pu]},$$scope:{ctx:s}}}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},p(a,[o]){const l={};o&2&&(l.label=a[1]),o&4&&(l.tooltip=a[2]),o&65&&(l.$$scope={dirty:o,ctx:a}),e.$set(l)},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function Lu(s,e,t){let{data:a}=e,{name:o=""}=e,{tooltip:l=void 0}=e;const n=De();function c(){a=this.value,t(0,a)}function i(){a=this.value,t(0,a)}return s.$$set=u=>{"data"in u&&t(0,a=u.data),"name"in u&&t(1,o=u.name),"tooltip"in u&&t(2,l=u.tooltip)},s.$$.update=()=>{s.$$.dirty&1&&(a||!a)&&n("save")},[a,o,l,c,i]}class Fu extends ue{constructor(e){super(),he(this,e,Lu,Ou,pe,{data:0,name:1,tooltip:2})}}class Ne extends Ae{constructor(t,a,o="#12cfab"){super();r(this,"component",Fu);r(this,"name");r(this,"key");r(this,"data");r(this,"tooltip");r(this,"setTooltip",t=>(this.tooltip=t,this));r(this,"clone",()=>new Ne(this.name,this.key,this.data));r(this,"getData",()=>{const t={};return t[this.key]=this.data||0,t});r(this,"deserialize",t=>this.data=t.get(this.key,"#12cfab"));this.name=t,this.key=a,this.data=o}}const Oo=class extends ne{constructor(){super({name:"Block Break",description:"Applies skill effects when a player breaks a block matching the given details",data:[new oo("The type of block expected to be broken","The expected data value of the block (-1 for any data value)")]})}};let tt=Oo;r(tt,"new",()=>new Oo);const Lo=class extends ne{constructor(){super({name:"Block Place",description:"Applies skill effects when a player places a block matching the given details",data:[new oo("The type of block expected to be placed","The expected data value of the block (-1 for any data value)")]})}};let at=Lo;r(at,"new",()=>new Lo);const Fo=class extends ne{constructor(){super({name:"Cast",description:"Applies skill effects when a player casts the skill using either the cast command, the skill bar, or click combos"})}};let st=Fo;r(st,"new",()=>new Fo);const Vo=class extends ne{constructor(){super({name:"Cleanup",description:"Applies skill effects when the player disconnects or unlearns the skill. This is always applied with a skill level of 1 just for the sake of math"})}};let ot=Vo;r(ot,"new",()=>new Vo);const Ro=class extends ne{constructor(){super({name:"Crouch",description:"Applies skill effects when a player starts or stops crouching using the shift key",data:[new _("Crouching","type",["Start Crouching","Stop Crouching","Both"])]})}};let nt=Ro;r(nt,"new",()=>new Ro);const No=class extends ne{constructor(){super({name:"Death",description:"Applies skill effects when a player dies"})}};let it=No;r(it,"new",()=>new No);const qo=class extends ne{constructor(){super({name:"Drop Item",description:"Applies skill effects upon dropping an item",data:[new _("Drop multiple","drop multiple",["True","False","Ignore"],"Ignore").setTooltip("Whether the player has to drop multiple items or a single item")]})}};let lt=qo;r(lt,"new",()=>new qo);const xo=class extends ne{constructor(){super({name:"Environment Damage",description:"Applies skill effects when a player takes environmental damage",data:[new _("Type","type",Do,"Fall").setTooltip("The source of damage to apply for")]})}};let rt=xo;r(rt,"new",()=>new xo);const Ho=class extends ne{constructor(){super({name:"Fishing",description:"Applies skill effects upon right-clicking with a fishing rod"})}};let ct=Ho;r(ct,"new",()=>new Ho);const Co=class extends ne{constructor(){super({name:"Fishing Bite",description:"Applies skill effects when a fish bites the fishing rod of a player"})}};let ut=Co;r(ut,"new",()=>new Co);const Wo=class extends ne{constructor(){super({name:"Fishing Fail",description:"Applies skill effects when a player fails to catch a fish due to poor timing"})}};let ht=Wo;r(ht,"new",()=>new Wo);const Bo=class extends ne{constructor(){super({name:"Fishing Grab",description:"Applies skill effects when a player catches a fish"})}};let pt=Bo;r(pt,"new",()=>new Bo);const Uo=class extends ne{constructor(){super({name:"Fishing Ground",description:"Applies skill effects when the bobber of a fishing rod hits the ground"})}};let dt=Uo;r(dt,"new",()=>new Uo);const Go=class extends ne{constructor(){super({name:"Fishing Reel",description:"Applies skill effects when a player reels in a fishing rod out of water or air with no fish on the rod"})}};let ft=Go;r(ft,"new",()=>new Go);const Ko=class extends ne{constructor(){super({name:"Initialize",description:"Applies skill effects immediately. This can be used for passive abilities"})}};let mt=Ko;r(mt,"new",()=>new Ko);const zo=class extends ne{constructor(){super({name:"Item Swap",description:"Applies skill effects upon pressing the swap-key on your keyboard",data:[new F("Cancel Swap","cancel",!0).setTooltip("True cancels the item swap. False allows the item swap")]})}};let gt=zo;r(gt,"new",()=>new zo);const Yo=class extends ne{constructor(){super({name:"Kill",description:"Applies skill effects upon killing something"})}};let wt=Yo;r(wt,"new",()=>new Yo);const jo=class extends ne{constructor(){super({name:"Land",description:"Applies skill effects when a player lands on the ground",data:[new X("Min Distance","min-distance").setTooltip("The minimum distance the player should fall before effects activate")]})}};let yt=jo;r(yt,"new",()=>new jo);const Zo=class extends ne{constructor(){super({name:"Launch",description:"Applies skill effects when a player launches a projectile",data:[new _("Type","type",Ar,"Any").setTooltip("The type of projectile that should be launched")]})}};let Tt=Zo;r(Tt,"new",()=>new Zo);const Xo=class extends ne{constructor(){super({name:"Left Click",description:"Applies skill effects upon performing a left-click",data:[new _("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").setTooltip("If the player has to be crouching in order for this trigger to function")]})}};let vt=Xo;r(vt,"new",()=>new Xo);const Jo=class extends ne{constructor(){super({name:"Move",description:"Applies skill effects when a player moves around. This triggers every tick the player is moving, so use this sparingly. Use the 'api-moved' value to check/use the distance traveled"})}};let bt=Jo;r(bt,"new",()=>new Jo);const Qo=class extends ne{constructor(){super({name:"Physical Damage",description:"Applies skill effects when a player deals physical (or non-skill) damage. This includes melee attacks and firing a bow",data:[new F("Target Caster","target",!0).setTooltip("True makes the children target the caster. False makes children target the damaged entity"),new _("Type","type",["Both","Melee","Projectile"],"Both").setTooltip("The type of damage dealt"),new X("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt")]})}};let kt=Qo;r(kt,"new",()=>new Qo);const Mo=class extends ne{constructor(){super({name:"Right Click",description:"Applies skill effects upon performing a right-click (NOTE: When clicking in air, you have to have an item in your hand)",data:[new _("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").setTooltip("If the player has to be crouching in order for this trigger to function")]})}};let _t=Mo;r(_t,"new",()=>new Mo);const en=class extends ne{constructor(){super({name:"Skill Cast",description:"Applies skill effects when a player casts a skill",data:[new F("Cancel Cast","cancel",!1).setTooltip("True cancels the skill cast. False allows the skill cast"),new Ve("Classes","allowed-classes").setTooltip("The list of classes which will trigger this effect. Leave blank to allow all to trigger. Use '!xxx' to exclude"),new Ve("Skills","allowed-skills").setTooltip("The list of skills which will trigger this effect. Leave blank to allow all to trigger. Use '!xxx' to exclude")]})}};let At=en;r(At,"new",()=>new en);const tn=class extends ne{constructor(){super({name:"Skill Damage",description:"Applies skill effects when a player deals damage with a skill",data:[new F("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the damaged entity"),new X("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new X("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt"),new Ve("Category","category",["default"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage")]})}};let Et=tn;r(Et,"new",()=>new tn);const an=class extends ne{constructor(){super({name:"Took Physical Damage",description:"Applies skill effects when a player takes physical (or non-skill) damage. This includes melee attacks and projectiles not fired by a skill",data:[new F("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new _("Type","type",["Both","Melee","Projectile"],"Both").setTooltip("The type of damage dealt"),new X("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new X("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt")]})}};let St=an;r(St,"new",()=>new an);const sn=class extends ne{constructor(){super({name:"Took Skill Damage",description:"Applies skill effects when a player takes damage from a skill other than their own",data:[new F("Target Caster","target",!0).setTooltip("True makes children target the caster. False makes children target the attacking entity"),new X("Min Damage","dmg-min",0).setTooltip("The minimum damage that needs to be dealt"),new X("Max Damage","dmg-max",999).setTooltip("The maximum damage that needs to be dealt"),new Ve("Category","category",["default"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage")]})}};let Dt=sn;r(Dt,"new",()=>new sn);const io=()=>[new _("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to get"),new F("Through Wall","wall",!1).setTooltip("Whether to allow targets to be on the other side of a wall"),new _("Include Caster","caster",["True","False","In area"],"False").setTooltip('Whether to include the caster in the target list. "True" will always include them, "False" will never, and "In area" will only if they are within the targeted area'),new g("Max Targets","max",99).setTooltip("The max amount of targets to apply children to")],on=class extends qe{constructor(){super({name:"Area",description:"Targets all units in a radius from the current target (the casting player is the default target)",data:[new g("Radius","radius",3).setTooltip("The radius of the area to target in blocks"),...io(),new F("Random","random",!1).setTooltip("Whether to randomize the targets selected")]})}};let It=on;r(It,"new",()=>new on);const nn=class extends qe{constructor(){super({name:"Cone",description:"Targets all units in a line in front of the current target (the casting player is the default target). If you include the caster, that counts towards the max amount",data:[new g("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new g("Angle","angle",90).setTooltip("The angle of the cone arc in degrees"),...io()]})}};let $t=nn;r($t,"new",()=>new nn);const ln=class extends qe{constructor(){super({name:"Linear",description:"Targets all units in a line in front of the current target (the casting player is the default target)",data:[new g("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new g("Tolerance","tolerance").setTooltip("How much to expand the potential entity's hit-box in all directions, in blocks. This makes it easier to aim"),...io()]})}};let Pt=ln;r(Pt,"new",()=>new ln);const rn=class extends qe{constructor(){super({name:"Location",description:"Targets the location the target or caster is looking at. Combine this with another targeting type for ranged area effects",data:[new g("Range","range",5).setTooltip("The max distance the location can be from the target's eyes"),new F("Entities","entities",!0).setTooltip("True to account for entities, or false to pass through them"),new F("Fluids","fluids",!1).setTooltip("True to account for fluids (water and lava), or false to pass through them"),new F("Passable blocks","passable",!0).setTooltip("True to account for passable or non-collidable blocks (grass, saplings, etc), or false to pass through them"),new F("Center","center",!1).setTooltip("Whether to move the hit location to the center of the block")]})}};let Ot=rn;r(Ot,"new",()=>new rn);const cn=class extends qe{constructor(){super({name:"Nearest",description:"Targets the closest unit(s) in a radius from the current target (the casting player is the default target). If you include the caster, that counts towards the max number",data:[new g("Range","range",3).setTooltip("The radius of the area to target in blocks"),...io()]})}};let Lt=cn;r(Lt,"new",()=>new cn);const un=class extends qe{constructor(){super({name:"Offset",description:"Targets a location that is the given offset away from each target",data:[new ke("Offset"),new g("Forward","forward").setTooltip("The offset from the target in the direction they are facing. Negative numbers go backwards"),new g("Upward","upward",2,.5).setTooltip("The offset from the target upwards. Negative numbers go below them"),new g("Right","right").setTooltip("The offset from the target to their right. Negative numbers go to the left")]})}};let Ft=un;r(Ft,"new",()=>new un);const hn=class extends qe{constructor(){super({name:"Remember",description:'Targets entities stored using the "Remember Targets" mechanic for the matching key. If it was never set, this will fail',data:[new R("Key","key","target").setTooltip('The unique key for the target group that should match that used by the "Remember Targets" skill')]})}};let Vt=hn;r(Vt,"new",()=>new hn);const pn=class extends qe{constructor(){super({name:"Self",description:"Returns the current target back to the caster"})}};let Rt=pn;r(Rt,"new",()=>new pn);const dn=class extends qe{constructor(){super({name:"Single",description:"Targets a single unit in front of the current target (the casting player is the default target)",data:[new g("Range","range",5).setTooltip("The max distance away any target can be in blocks"),new g("Tolerance","tolerance").setTooltip("How much to expand the potential entity's hitbox in all directions, in blocks. This makes it easier to aim"),new _("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to get"),new F("Through Wall","wall",!1).setTooltip("Whether to allow targets to be on the other side of a wall")]})}};let Nt=dn;r(Nt,"new",()=>new dn);const je=()=>[new F("Check Material","check-mat",!0).setTooltip("Whether the item needs to be a certain type"),new We(!0,"Arrow").requireValue("check-mat",[!0]).setTooltip("The type the item needs to be"),new F("Check Data","check-data",!1).setTooltip("Whether the item needs to have a certain data value"),new oe("Data","data").requireValue("check-data",[!0]).setTooltip("The data value the item must have"),new F("Check Lore","check-lore",!1).setTooltip("Whether the item requires a bit of text in its lore"),new R("Lore","lore","text").requireValue("check-lore",[!0]).setTooltip("The text the item requires in its lore"),new F("Check Name","check-name",!1).setTooltip("Whether the item needs to have a bit of text in its display name"),new R("Name","name","name").requireValue("check-name",[!0]).setTooltip("The text the item requires in its display name"),new F("Regex","regex",!1).setTooltip("Whether the name and lore checks are regex strings. If you do not know what regex is, leave this option alone")],fn=class extends J{constructor(){super({name:"Altitude",description:"Applies child components whenever the player is on a certain height-level",data:[new g("Min","min").setTooltip("The minimum height a player has to be on"),new g("Max","max").setTooltip("The maximum height a player can be on")]})}};let qt=fn;r(qt,"new",()=>new fn);const mn=class extends J{constructor(){super({name:"Armor",description:"Applies child components when the target is wearing an armor item matching the given details",data:[new _("Armor","armor",["Any","Helmet","Chestplate","Leggings","Boots"]).setTooltip("The type of armor to check"),...je()]})}};let xt=mn;r(xt,"new",()=>new mn);const gn=class extends J{constructor(){super({name:"Attribute",description:"Requires the target to have a given number of attributes",data:[new R("Attribute","attribute","Vitality").setTooltip("The name of the attribute you are checking the value of"),new g("Min","min").setTooltip("The minimum amount of the attribute the target requires"),new g("Max","max",999).setTooltip("The maximum amount of the attribute the target requires")]})}};let Ht=gn;r(Ht,"new",()=>new gn);const wn=class extends J{constructor(){super({name:"Biome",description:"Applies child components when in a specified biome",data:[new _("Type","type",["In Biome","Not In Biome"],"In Biome").setTooltip("Whether the target should be in the biome. If checking for in the biome, they must be in any one of the checked biomes. If checking for the opposite, they must not be in any of the checked biomes"),new _("Biome","biome",Jr,["Forest"],!0).setTooltip("The biomes to check for. The expectation would be any of the selected biomes need to match")]})}};let Ct=wn;r(Ct,"new",()=>new wn);const yn=class extends J{constructor(){super({name:"Block",description:"Applies child components if the target is currently standing on a block of the given type",data:[new _("Type","standing",["On Block","Not On Block","In Block","Not In Block"]).setTooltip(`Specifies which block to check and whether it should match the selected material. "On Block" is directly below the player while "In Block" is the block a player's feet are in`),new We().setTooltip("The type of the block to require the targets to stand on")]})}};let Wt=yn;r(Wt,"new",()=>new yn);const Tn=class extends J{constructor(){super({name:"Burning",description:"Applies child components if the caster burns or not",data:[new _("Type","burn",["Burn","Dont burn"],"Burn").setTooltip("Specifies whether the player has to be burning for this skill to be performed")]})}};let Bt=Tn;r(Bt,"new",()=>new Tn);const vn=class extends J{constructor(){super({name:"Ceiling",description:"Checks the height of the ceiling above each target",data:[new g("Distance","distance",5).setTooltip("How high to check for the ceiling"),new F("At least","at-least",!0).setTooltip("When true, the ceiling must be at least the give number of blocks high. If false, the ceiling must be lower than the given number of blocks")]})}};let Ut=vn;r(Ut,"new",()=>new vn);const bn=class extends J{constructor(){super({name:"Chance",description:"Rolls a chance to apply child components",data:[new g("Chance","chance",25).setTooltip('The chance to execute children as a percentage. "25" would be 25%')]})}};let Gt=bn;r(Gt,"new",()=>new bn);const kn=class extends J{constructor(){super({name:"Class",description:'Applies child components when the target is the given class or optionally a profession of that class. For example, if you check for "Fighter" which professes into "Warrior", a "Warrior" will pass the check if you do not enable "exact"',data:[new $o("Class","class",!1).setTooltip("The class the player should be"),new F("Exact","exact",!1).setTooltip("Whether the player must be exactly the given class. If false, they can be a later profession of the class")]})}};let Kt=kn;r(Kt,"new",()=>new kn);const _n=class extends J{constructor(){super({name:"Class Level",description:"Applies child components when the level of the class with this skill is within the range. This only checks the level of the caster, not the targets",data:[new oe("Min Level","min-level",2).setTooltip("The minimum class level the player should be. If the player has multiple classes, this will be of their main class"),new oe("Max Level","max-level",99).setTooltip("The maximum class level the player should be. If the player has multiple classes, this will be of their main class")]})}};let zt=_n;r(zt,"new",()=>new _n);const An=class extends J{constructor(){super({name:"Combat",description:"Applies child components to targets that are in/out of combat, depending on the settings",data:[new F("In Combat","combat",!0).setTooltip("Whether the target should be in or out of combat"),new X("Seconds","seconds",10).setTooltip("The time in seconds since the last combat activity before something is considered not in combat")]})}};let Yt=An;r(Yt,"new",()=>new An);const En=class extends J{constructor(){super({name:"Crouch",description:"Applies child components if the target player(s) are crouching",data:[new F("Crouching","crouch",!0).setTooltip("Whether the player should be crouching")]})}};let jt=En;r(jt,"new",()=>new En);const Sn=class extends J{constructor(){super({name:"Direction",description:"Applies child components when the target or caster is facing the correct direction relative to the other",data:[new _("Type","type",["Target","Caster"]).setTooltip("The entity to check the direction of"),new _("Direction","direction",["Away","Towards"]).setTooltip("The direction the chosen entity needs to be looking relative to the other")]})}};let Zt=Sn;r(Zt,"new",()=>new Sn);const Dn=class extends J{constructor(){super({name:"Elevation",description:"Applies child components when the elevation of the target matches the settings",data:[new _("Type","type",["Normal","Difference"]).setTooltip("The type of comparison to make. Normal is just their Y-coordinate. Difference would be the difference between that the caster's Y-coordinate"),new g("Min Value","min-value").setTooltip('The minimum value for the elevation required. A positive minimum value with a "Difference" type would be for when the target is higher up than the caster'),new g("Max Value","max-value",255).setTooltip('The maximum value for the elevation required. A negative maximum value with a "Difference" type would be for when the target is below the caster')]})}};let Xt=Dn;r(Xt,"new",()=>new Dn);const In=class extends J{constructor(){super({name:"Else",description:"Applies child elements if the previous component failed to execute. This not only applies for conditions not passing, but mechanics failing due to no target or other cases"})}};let Jt=In;r(Jt,"new",()=>new In);const $n=class extends J{constructor(){super({name:"Entity Type",description:"Applies child elements if the target matches one of the selected entity types",data:[new _("Types","types",Qr,[],!0).setTooltip("The entity types to target")]})}};let Qt=$n;r(Qt,"new",()=>new $n);const Pn=class extends J{constructor(){super({name:"Fire",description:"Applies child components when the target is on fire",data:[new _("Type","type",["On Fire","Not On Fire"],"On Fire").setTooltip("Whether the target should be on fire")]})}};let Mt=Pn;r(Mt,"new",()=>new Pn);const On=class extends J{constructor(){super({name:"Flag",description:"Applies child components when the target is marked by the appropriate flag",data:[new _("Type","type",["Set","Not Set"],"Set").setTooltip("Whether the flag should be set"),new R("Key","key","key").setTooltip("The unique key representing the flag. This should match the key for when you set it using the Flag mechanic or the Flat Toggle mechanic")]})}};let ea=On;r(ea,"new",()=>new On);const Ln=class extends J{constructor(){super({name:"Food",description:"Applies child components when the target's food level matches the settings",data:[new _("Type","type",["Food","Percent","Difference","Difference Percent"]).setTooltip("The type of measurement to use for the food. Food level is their flat food left. Percent is the percentage of food they have left. Difference is the difference between the target's flat food and the caster's. Difference percent is the difference between the target's percentage food left and the caster's"),new g("Min Value","min-value").setTooltip('The minimum food required. A positive minimum with one of the "Difference" types would be for when the target has more food'),new g("Max Value","max-value",10,2).setTooltip('The maximum food required. A negative maximum with one of the "Difference" types would be for when the target has less food')]})}};let ta=Ln;r(ta,"new",()=>new Ln);const Fn=class extends J{constructor(){super({name:"Ground",description:"Applies child components when the target is on the ground",data:[new _("Type","type",["On Ground","Not On Ground"]).setTooltip("Whether the target should be on the ground")]})}};let aa=Fn;r(aa,"new",()=>new Fn);const Vn=class extends J{constructor(){super({name:"Health",description:"Applies child components when the target's health matches the settings",data:[new _("Type","type",["Health","Percent","Difference","Difference Percent"]).setTooltip("The type of measurement to use for the health. Health is their flat health left. Percent is the percentage of health they have left. Difference is the difference between the target's flat health and the caster's. Difference percent is the difference between the target's percentage health left and the caster's"),new g("Min Value","min-value").setTooltip('The minimum health required. A positive minimum with one of the "Difference" types would be for when the target has more health'),new g("Max Value","max-value",10,2).setTooltip('The maximum health required. A negative maximum with one of the "Difference" types would be for when the target has less health')]})}};let sa=Vn;r(sa,"new",()=>new Vn);const Rn=class extends J{constructor(){super({name:"Item",description:"Applies child components when the target is wielding an item matching the given material",data:[...je()]})}};let oa=Rn;r(oa,"new",()=>new Rn);const Nn=class extends J{constructor(){super({name:"Inventory",description:"Applies child components when the target player contains the given item in their inventory. This does not work on mobs",data:[new g("Amount","amount",1).setTooltip("The amount of the item needed in the player's inventory"),...je()]})}};let na=Nn;r(na,"new",()=>new Nn);const qn=class extends J{constructor(){super({name:"Light",description:"Applies child components when the light level at the target's location matches the settings",data:[new g("Min Light","min-light").setTooltip("The minimum light level needed. 16 is full brightness while 0 is complete darkness"),new g("Max Light","max-light",16,16).setTooltip("The maximum light level needed. 16 is full brightness while 0 is complete darkness")]})}};let ia=qn;r(ia,"new",()=>new qn);const xn=class extends J{constructor(){super({name:"Mana",description:"Applies child components when the target's mana matches the settings",data:[new _("Type","type",["Mana","Percent","Difference","Difference Percent"],"Mana").setTooltip("The type of measurement to use for the mana. Mana is their flat mana left. Percent is the percentage of mana they have left. Difference is the difference between the target's flat mana and the caster's. Difference percent is the difference between the target's percentage mana left and the caster's"),new g("Min Value","min-value").setTooltip("The minimum amount of mana needed"),new g("Max Value","max-value",10,2).setTooltip("The maximum amount of mana needed")]})}};let la=xn;r(la,"new",()=>new xn);const Hn=class extends J{constructor(){super({name:"Money",description:"Applies child components when the target's balance matches the settings (requires Vault and an economy plugin). Always is false for non-player targets",data:[new _("Type","type",["Min","Max","Between"],"Min").setTooltip("The type of comparison to make"),new g("Min Value","min-value",10).requireValue("type",["Min","Between"]).setTooltip("The minimum balance the target must have, inclusive"),new g("Max Value","max-value",100).requireValue("type",["Max","Between"]).setTooltip("The maximum balance the target can have, inclusive")]})}};let ra=Hn;r(ra,"new",()=>new Hn);const Cn=class extends J{constructor(){super({name:"Mounted",description:"Applies child elements if the target is being mounted by one of the selected entity types",data:[new _("Types","types",Er,["Any"],!0).setTooltip("The entity types that can be mounting the target")]})}};let ca=Cn;r(ca,"new",()=>new Cn);const Wn=class extends J{constructor(){super({name:"Mounting",description:"Applies child elements if the target is mounting one of the selected entity types",data:[new _("Types","types",Er,["Any"],!0).setTooltip("The entity types the target can be mounting")]})}};let ua=Wn;r(ua,"new",()=>new Wn);const Bn=class extends J{constructor(){super({name:"MythicMob Type",description:"Applies child elements if the target corresponds to one of the entered MythicMob types, or is not a MythicMob if left empty",data:[new Ve("MythicMob Types","types").setTooltip("The MythicMob types to target")]})}};let ha=Bn;r(ha,"new",()=>new Bn);const Un=class extends J{constructor(){super({name:"Name",description:"Applies child components when the target has a name matching the settings",data:[new F("Contains Text","contains",!0).setTooltip("Whether the target should have a name containing the text"),new F("Regex","regex",!1).setTooltip("Whether the text is formatted as regex. If you do not know what regex is, ignore this option"),new R("Text","text","text").setTooltip("The text to look for in the target's name")]})}};let pa=Un;r(pa,"new",()=>new Un);const Gn=class extends J{constructor(){super({name:"Offhand",description:"Applies child components when the target is wielding an item matching the given material as an offhand item. This is for v1.9+ servers only",data:[...je()]})}};let da=Gn;r(da,"new",()=>new Gn);const Kn=class extends J{constructor(){super({name:"Permission",description:"Applies child components if the caster has the required permission",data:[new R("Permission","perm","some.permission").setTooltip("The permission the player needs to have")]})}};let fa=Kn;r(fa,"new",()=>new Kn);const zn=class extends J{constructor(){super({name:"Potion",description:"Applies child components when the target has the potion effect",data:[new _("Type","type",["Active","Not Active"],"Active").setTooltip("Whether the potion should be active"),new _("Potion","potion",Mr,"Any").setTooltip("The type of potion to look for"),new g("Min Rank","min-rank").setTooltip("The minimum rank the potion effect can be"),new g("Max Rank","max-rank",999).setTooltip("The maximum rank the potion effect can be")]})}};let ma=zn;r(ma,"new",()=>new zn);const Yn=class extends J{constructor(){super({name:"Skill Level",description:"Applies child components when the skill level is with the range. This checks the skill level of the caster, not the targets",data:[new no("Skill","skill",!1).setTooltip("The name of the skill to check the level of. If you want to check the current skill, enter the current skill's name anyway"),new oe("Min Level","min-level",2).setTooltip("The minimum level of the skill needed"),new oe("Max Level","max-level",99).setTooltip("The maximum level of the skill needed")]})}};let ga=Yn;r(ga,"new",()=>new Yn);const jn=class extends J{constructor(){super({name:"Slot",description:"Applies child components when the target player has a matching item in the given slot",data:[new Ve("Slots (one per line)","slot",["9"]).setTooltip("The slots to look at. Slots 0-8 are the hot bar, 9-35 are the main inventory, 36-39 are armor, and 40 is the offhand slot. Multiple slots will check if any of the slots match"),...je()]})}};let wa=jn;r(wa,"new",()=>new jn);const Zn=class extends J{constructor(){super({name:"Status",description:"Applies child components when the target has the status condition",data:[new _("Type","type",["Active","Not Active"]).setTooltip("Whether the status should be active"),new _("Status","status",["Any","Absorb","Curse","Disarm","Invincible","Root","Silence","Stun"]).setTooltip("The status to look for")]})}};let ya=Zn;r(ya,"new",()=>new Zn);const Xn=class extends J{constructor(){super({name:"Time",description:"Applies child components when the server time matches the settings",data:[new _("Time","time",["Day","Night"],"Day").setTooltip("The time to check for in the current world")]})}};let Ta=Xn;r(Ta,"new",()=>new Xn);const Jn=class extends J{constructor(){super({name:"Tool",description:"Applies child components when the target is wielding a matching tool",data:[new _("Material","material",["Any","Wood","Stone","Iron","Gold","Diamond","Netherite"]).setTooltip("The material the held tool needs to be made out of"),new _("Tool","tool",["Any","Axe","Hoe","Pickaxe","Shovel","Sword"]).setTooltip("The type of tool it needs to be")]})}};let va=Jn;r(va,"new",()=>new Jn);const Qn=class extends J{constructor(){super({name:"Value",description:"Applies child components if a stored value is within the given range",data:[new R("Key","key","value").setTooltip("The unique string used for the value set by the Value mechanics"),new g("Min Value","min-value",1).setTooltip("The lower bound of the required value"),new g("Max Value","max-value",999).setTooltip("The upper bound of the required value")]})}};let ba=Qn;r(ba,"new",()=>new Qn);const Mn=class extends J{constructor(){super({name:"Water",description:"Applies child components when the target is in or out of water, depending on the settings",data:[new _("State","state",["In Water","Out Of Water"]).setTooltip("Whether the target needs to be in the water")]})}};let ka=Mn;r(ka,"new",()=>new Mn);const ei=class extends J{constructor(){super({name:"Weather",description:"Applies child components when the target's location has the given weather condition",data:[new _("Type","type",["Rain","None","Snow","Thunder"]).setTooltip("Whether the target needs to be in the water")]})}};let _a=ei;r(_a,"new",()=>new ei);const ti=class extends J{constructor(){super({name:"World",description:"Applies child components when the target is in a specific world",data:[new F("Blacklist","blacklist",!1).setTooltip("Whether the list should be seen as a blacklist"),new Ve("Worlds","worlds").setTooltip("Which worlds should be taken into consideration")]})}};let Aa=ti;r(Aa,"new",()=>new ti);const lo=()=>[new ke("Item Options"),new We(!0,"Arrow").setTooltip("The type of item to give to the player"),new oe("Amount","amount",1).setTooltip("The quantity of the item to give to the player"),new oe("Durability","data").requireValue("material",Wl()).setTooltip("The durability to reduce from the item"),new F("Unbreakable","unbreakable",!1).requireValue("material",Wl()).setTooltip("Whether to make the item unbreakable"),new oe("CustomModelData","byte",0).setTooltip("The CustomModelData of the item"),new _("Hide Flags","hide-flags",["Enchants","Attributes","Unbreakable","Destroys","Placed on","Potion effects","Dye"],[],!0).setTooltip("Flags to hide from the item"),new F("Custom Name/Lore","custom",!1).setTooltip("Whether to apply a custom name/lore to the item"),new R("Name","name","Name").requireValue("custom",[!0]).setTooltip("The name of the item"),new Ve("Lore","lore").requireValue("custom",[!0]).setTooltip("The lore text for the item (the text below the name)"),new Ne("Potion Color","potion_color","#385dc6").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion color in hex RGB"),new _("Potion Type","potion_type",Dr,"Speed").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The type of potion"),new oe("Potion Level","potion_level").requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion level"),new oe("Potion Duration","potion_duration",30).requireValue("material",["Potion","Splash potion","Lingering potion"]).setTooltip("The potion duration (seconds)"),new Ne("Armor Color","armor_color","#a06540").requireValue("material",["Leather helmet","Leather chestplate","Leather leggings","Leather boots"]).setTooltip("The armor color in hex RGB")],ro=()=>[new ke("Particle Options"),new _("Particle","particle",Ir,"Villager happy").setTooltip("The type of particle to display"),new We(!1).requireValue("particle",["Item crack","Block crack","Block dust","Falling dust","Block marker"]).setTooltip("The material to use for the particles"),new oe("Durability","durability",0).requireValue("particle",["Item crack"]).setTooltip("The durability to be reduced from the item used to make the particles"),new oe("CustomModelData","type",0).requireValue("particle",["Item crack"]).setTooltip("The CustomModelData of the item used to make the particles"),new Ne("Dust Color","dust-color","#FF0000").requireValue("particle",["Redstone","Dust color transition"]).setTooltip("The color of the dust particles in hex RGB"),new Ne("Final Dust Color","final-dust-color","#FF0000").requireValue("particle",["Dust color transition"]).setTooltip("The color to transition to, in hex RGB"),new X("Dust Size","dust-size",1).requireValue("particle",["Redstone","Dust color transition"]).setTooltip("The size of the dust particles"),new _("Arrangement","arrangement",["Sphere","Circle","Hemisphere"],"Sphere").setTooltip("The arrangement to use for the particles. Circle is a 2D circle, Hemisphere is half a 3D sphere, and Sphere is a 3D sphere"),new _("Circle Direction","direction",["XY","XZ","YZ"],"XZ").requireValue("arrangement",["Circle"]).setTooltip("The orientation of the circle. XY and YZ are vertical circles while XZ is a horizontal circle"),new g("Radius","radius",1).setTooltip("The radius of the arrangement in blocks"),new g("Points","particles",20).setTooltip("The amount of points that conform the chosen arrangement"),new oe("Effect Data","data").requireValue("particle",["Smoke","Ender Signal","Mobspawner Flames","Potion Break","Sculk charge"]).setTooltip("The data value to use for the particle. The effect changes between particles such as the orientation for smoke particles or the color for potion break"),new oe("Visible Radius","visible-radius",25).setTooltip("How far away players can see the particles from in blocks"),new X("DX","dx").setTooltip("Offset in the X direction, used as the Red value for some particles"),new X("DY","dy").setTooltip("Offset in the Y direction, used as the Green value for some particles"),new X("DZ","dz").setTooltip("Offset in the Z direction, used as the Blue value for some particles"),new X("Amount","amount",1).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color'),new X("Speed","speed",.1).setTooltip("Speed of the particle. For some particles controls other parameters, such as size")],Po=()=>[new ke("Projectile Options"),new g("Velocity","velocity",3).setTooltip("How fast the projectile is launched. A negative value fires it in the opposite direction."),new g("Lifespan","lifespan",5).setTooltip("How long in secods before the projectile will expire in case it doesn't hit anything."),new _("Spread","spread",["Cone","Horizontal Cone","Rain"],"Cone").setTooltip('The orientation for firing projectiles. Cone will fire arrows in a cone centered on your reticle. Horizontal cone does the same as cone, just locked to the XZ axis (parallel to the ground). Rain drops the projectiles from above the target. For firing one arrow straight, use "Cone"'),new g("Amount","amount",1).setTooltip("The number of projectiles to fire"),new g("Angle","angle",30).requireValue("spread",["Cone","Horizontal Cone"]).setTooltip("The angle in degrees of the cone arc to spread projectiles over. If you are only firing one projectile, this does not matter."),new g("Height","height",8).requireValue("spread",["Rain"]).setTooltip("The distance in blocks over the target to rain the projectiles from"),new g("Radius","rain-radius",2).requireValue("spread",["Rain"]).setTooltip("The radius of the rain emission area in blocks"),new ke("Offset"),new g("Forward Offset","forward").setTooltip("How far forward in front of the target the projectile should fire from in blocks. A negative value will put it behind."),new g("Upward Offset","upward").setTooltip("How far above the target the projectile should fire from in blocks. A negative value will put it below."),new g("Right Offset","right").setTooltip("How far to the right of the target the projectile should fire from. A negative value will put it to the left.")],Vu=s=>(s.requireValue("use-effect",[!0]),s),Ru=s=>s,co=s=>{let e=Ru;return s&&(e=Vu),[new ke("Particle Effect Options"),new F("Use Effect","use-effect").setTooltip("Whether to use a particle effect."),e(new R("Effect Key","effect-key","default").setTooltip("The key to refer to the effect by. Only one effect of each key can be active at a time.")),e(new g("Duration","duration",1).setTooltip("The time to play the effect for in seconds")),e(new R("Shape","-shape","hexagon").setTooltip('Key of a formula for deciding where particles are played each iteration. View "effects.yml" for a list of defined formulas and their keys.')),e(new _("Shape Direction","-shape-dir",["XY","YZ","XZ"],"XY").setTooltip("The plane the shape formula applies to. XZ would be flat, the other two are vertical.")),e(new R("Shape Size","-shape-size","1").setTooltip("Formula for deciding the size of the shape. This can be any sort of formula using the operations defined in the wiki.")),e(new R("Animation","-animation","one-circle").setTooltip('Key of a formula for deciding where the particle effect moves relative to the target. View "effects.yml" for a list of defined formulas and their keys.')),e(new _("Animation Direction","-anim-dir",["XY","YZ","XZ"],"XZ").setTooltip("The plane the animation motion moves through. XZ wold be flat, the other two are vertical.")),e(new R("Animation Size","-anim-size","1").setTooltip("Formula for deciding the multiplier of the animation distance. This can be any sort of formula using the operations defined in the wiki.")),e(new oe("Interval","-interval",1).setTooltip("Number of ticks between playing particles.")),e(new oe("View Range","-view-range",25).setTooltip("How far away the effect can be seen from.")),e(new _("Particle","-particle-type",Ir,"Villager happy").setTooltip("The type of particle to use.")),e(new _("Material","-particle-material",eo,"Dirt").requireValue("-particle-type",["Item crack","Block crack","Block dust","Falling dust","Block marker"]).setTooltip("The material to use for the particle.")),e(new oe("Durability","-particle-durability").requireValue("particle",["Item crack"]).setTooltip("The durability to be reduced from the item used to make the particles")),e(new oe("CustomModelData","-particle-data").requireValue("-particle-type",["Item crack"]).setTooltip("The data value for the material used by the particle. For 1.14+ determines the CustomModelData of the item.")),new Ne("Dust Color","-particle-dust-color","#FF0000").requireValue("-particle-type",["Redstone","Dust color transition"]).setTooltip("The color of the dust particles in hex RGB"),new Ne("Final Dust Color","-particle-final-dust-color","#FF0000").requireValue("-particle-type",["Dust color transition"]).setTooltip("The color to transition to, in hex RGB"),new X("Dust Size","-particle-dust-size",1).requireValue("-particle-type",["Redstone","Dust color transition"]).setTooltip("The size of the dust particles"),e(new oe("Amount","-particle-amount",1).setTooltip('Number of particles to play per point. For "Spell mob" and "Spell mob ambient" particles, set to 0 to control the particle color.')),e(new X("DX","-particle-dx").setTooltip("Offset in the X direction, used as the Red value for some particles.")),e(new X("DY","-particle-dy").setTooltip("Offset in the Y direction, used as the Green value for some particles.")),e(new X("DZ","-particle-dz").setTooltip("Offset in the Z direction, used as the Blue value for some particles.")),e(new X("Speed","-particle-speed",.1).setTooltip("Speed of the particle. For some particles controls other parameters, such as size.")),e(new X("Initial Rotation","-initial-rotation").setTooltip("The amount to rotate the effect (useful for effects like the square).")),e(new F("Rotate w/ Player","-with-rotation",!0).setTooltip("Whether to follow the rotation of the player for the effect."))]},ai=class extends O{constructor(){super({name:"Armor",description:"Sets the specified armor slot of the target to the item defined by the settings",data:[new _("Slot","slot",["Hand","Off Hand","Feet","Legs","Chest","Head"]).setTooltip("The slot number to set the item to"),new F("Overwrite","overwrite",!1).setTooltip("USE WITH CAUTION. Whether to overwrite an existing item in the slot. If true, will permanently delete the existing iem"),...lo()]})}};let Ea=ai;r(Ea,"new",()=>new ai);const si=class extends O{constructor(){super({name:"Armor Stand",description:"Summons an armor stand that can be used as a marker or for item display (check Armor Mechanic for latter). Applies child components on the armor stand",data:[new R("Armor Stand Key","key","default").setTooltip("The key to refer to the armor stand by. Only one armor stand of each key can be active per target at a time"),new g("Duration","duration",5).setTooltip("How long the armor stand lasts before being deleted"),new R("Name","name","Armor Stand").setTooltip("The name the armor stand displays"),new F("Name visible","name-visible",!1).setTooltip("Whether the armor stand's name should be visible from afar"),new F("Follow target","follow",!1).setTooltip("Whether the armor stand should follow the target"),new F("Apply gravity","gravity",!0).setTooltip("Whether the armor stand should be affected by gravity"),new F("Small","tiny",!1).setTooltip("Whether the armor stand should be small"),new F("Show arms","arms",!1).setTooltip("Whether the armor stand should display its arms"),new F("Show base plate","base",!1).setTooltip("Whether the armor stand should display its base plate"),new F("Visible","visible",!0).setTooltip("Whether the armor stand should be visible"),new F("Marker","marker",!0).setTooltip("Setting this to true will remove the armor stand's hitbox"),new ke("Offset"),new g("Forward Offset","forward").setTooltip("How far forward in front of the target the armor stand should be in blocks. A negative value will put it behind"),new g("Upward Offset","upward").setTooltip("How far above the target the armor stand should be in blocks. A negative value will put it below"),new g("Right Offset","right").setTooltip("How far to the right the armor stand should be of the target. A negative value will put it to the left")]},!0)}};let Sa=si;r(Sa,"new",()=>new si);const oi=class extends O{constructor(){super({name:"Armor Stand Pose",description:"Sets the pose of an armor stand target. Values should be in the format x,y,z where rotations are in degrees. Example: 0.0,0.0,0.0",data:[new R("Head","head","").setTooltip("The pose values of the head. Leave empty if should be ignored"),new R("Body","body","").setTooltip("The pose values of the body. Leave empty if should be ignored"),new R("Left Arm","left-arm","").setTooltip("The pose values of the left arm. Leave empty if should be ignored"),new R("Right Arm","right-arm","").setTooltip("The pose values of the right arm. Leave empty if should be ignored"),new R("Left Leg","left-leg","").setTooltip("The pose values of the left leg. Leave empty if should be ignored"),new R("Right Leg","right-leg","").setTooltip("The pose values of the right leg. Leave empty if should be ignored")]})}};let Da=oi;r(Da,"new",()=>new oi);const ni=class extends O{constructor(){super({name:"Attribute",description:"Gives a player bonus attributes temporarily",data:[new R("Attribute","key","Intelligence").setTooltip("The name of the attribute to add to"),new _("Operation","operation",["ADD_NUMBER","MULTIPLY_PERCENTAGE"],"ADD_NUMBER").setTooltip("The operation on the original value by amount, ADD_NUMBER: Scalar adding, MULTIPLY_PERCENTAGE: Multiply the value by amount"),new g("Amount","amount",5,2).setTooltip("The amount to use with the operation"),new g("Seconds","seconds",3).setTooltip("How long in seconds to give the attributes to the player"),new F("Stackable","stackable",!1).setTooltip("Whether applying multiple times stacks the effects")]})}};let Ia=ni;r(Ia,"new",()=>new ni);const ii=class extends O{constructor(){super({name:"Block",description:"Changes blocks to the given type of block for a limited duration",data:[new _("Shape","shape",["Sphere","Cuboid"],"Sphere").setTooltip("The shape of the region to change the blocks for"),new _("Type","type",()=>["Air","Any","Solid",...eo()],"Solid").setTooltip("The type of blocks to replace. Air or any would be for making obstacles while solid would change the environment"),new _("Block","block",eo,"Ice").setTooltip("The type of block to turn the region into"),new oe("Block Data","data").setTooltip("The block data to apply, mostly applicable for things like signs, woods, steps, or the similar"),new F("Reset Yaw","reset-yaw",!1).setTooltip("Whether the target's yaw should be reset, effectively making the offsets cardinally aligned"),new g("Seconds","seconds",5).setTooltip("How long the blocks should be replaced for"),new g("Radius","radius",3).requireValue("shape",["Sphere"]).setTooltip("The radius of the sphere region in blocks"),new g("Width (X)","width",5).requireValue("shape",["Cuboid"]).setTooltip("The width of the cuboid in blocks"),new g("Height (Y)","height",5).requireValue("shape",["Cuboid"]).setTooltip("The height of the cuboid in blocks"),new g("Depth (Z)","depth",5).requireValue("shape",["Cuboid"]).setTooltip("The depth of the cuboid in blocks"),new ke("Offset"),new g("Forward Offset","forward").setTooltip("How far forward in front of the target the region should be in blocks. A negative value will put it behind"),new g("Upward Offset","upward").setTooltip("How far above the target the region should be in blocks. A negative value will put it below"),new g("Right Offset","right").setTooltip("How far to the right the region should be of the target. A negative value will put it to the left")]})}};let $a=ii;r($a,"new",()=>new ii);const li=class extends O{constructor(){super({name:"Buff",description:"Buffs combat stats of the target",data:[new F("Immediate","immediate",!1).setTooltip("Whether to apply the buff to the current damage trigger"),new _("Type","type",["DAMAGE","DEFENSE","SKILL_DAMAGE","SKILL_DEFENSE","HEALING"],"DAMAGE").requireValue("immediate",[!1]).setTooltip("What type of buff to apply. DAMAGE/DEFENSE is for regular attacks, SKILL_DAMAGE/SKILL_DEFENSE are for damage from abilities, and HEALING is for healing from abilities"),new _("Modifier","modifier",["Flat","Multiplier"],"Flat").setTooltip("The sort of scaling for the buff. Flat will increase/reduce incoming damage by a fixed amount where Multiplier does it by a percentage of the damage. Multipliers above 1 will increase damage taken while multipliers below 1 reduce damage taken"),new R("Category","category","").requireValue("type",["SKILL_DAMAGE","SKILL_DEFENSE"]).setTooltip("What kind of skill damage to affect. If left empty, this will affect all skill damage"),new g("Value","value",1).setTooltip("The amount to increase/decrease incoming damage by"),new g("Seconds","seconds",3).requireValue("immediate",[!1]).setTooltip("The duration of the buff in seconds")]})}};let Pa=li;r(Pa,"new",()=>new li);const ri=class extends O{constructor(){super({name:"Cancel",description:"Cancels the event that caused the trigger this is under to go off. For example, damage based triggers will stop the damage that was dealt while the Launch trigger would stop the projectile from firing"})}};let Oa=ri;r(Oa,"new",()=>new ri);const ci=class extends O{constructor(){super({name:"Cancel Effect",description:"Stops a particle effect prematurely",data:[new R("Effect Key","effect-key","default").setTooltip("The key used when setting up the effect")]},!1)}};let La=ci;r(La,"new",()=>new ci);const ui=class extends O{constructor(){super({name:"Channel",description:"Applies child effects after a duration which can be interrupted. During the channel, the player cannot move, attack, or use other spells",data:[new F("Still","still",!0).setTooltip("Whether to hold the player in place while channeling"),new g("Time","time",3).setTooltip("The amouont of time, in seconds, to channel for")]},!0)}};let Fa=ui;r(Fa,"new",()=>new ui);const hi=class extends O{constructor(){super({name:"Cleanse",description:"Cleanses negative potion or status effects from the targets",data:[new _("Potion","potion",ec,void 0,!0).setTooltip("The type of potion effect to remove from the target"),new _("Status","status",["All","Curse","Disarm","Root","Silence","Stun"],void 0,!0).setTooltip("The status to remove from the target")]},!1)}};let Va=hi;r(Va,"new",()=>new hi);const pi=class extends O{constructor(){super({name:"Command",description:"Executes a command for each of the targets",data:[new R("Command","command","").setTooltip(`The command to execute. {player} = caster's name, {target} = target's name, {targetUUID} = target's UUID (useful if targets are non players), &lc: "{", &rc: "}", &sq: "'"`),new _("Execute Type","type",["Console","OP"],"OP").setTooltip("Console: executes the command from the console. OP: Only if the target is a player, will have them execute it while given a temporary OP permission (If server closes in the meantime, the permission might stay, not recommended!!)")]},!1)}};let Ra=pi;r(Ra,"new",()=>new pi);const di=class extends O{constructor(){super({name:"Cooldown",description:"Lowers the cooldowns of the target's skill(s). If you provide a negative amount, it will increase the cooldown",data:[new R('Skill (or "all")',"skill","all").setTooltip("The skill to modify the cooldown for"),new _("Type","type",["Seconds","Percent"],"Seconds").setTooltip("The modification unit to use. Seconds will add/subtract seconds from the cooldown while Percent will add/subtract a percentage of its full cooldown"),new g("Value","value",-1).setTooltip("The amount to add/subtract from the skill's cooldown")]},!1)}};let Na=di;r(Na,"new",()=>new di);const fi=class extends O{constructor(){super({name:"Damage",description:"Inflicts skill damage to each target. Multiplier type would be a percentage of the target health",data:[new _("Type","type",["Damage","Multiplier","Percent Left","Percent Missing"],"Damage").setTooltip("The unit to use for the amount of damage. Damage will deal flat damage, Multiplier will deal a percentage of the target's max health, Percent Left will deal a percentage of their current health, and Percent Missing will deal a percentage of the difference between their max health and current health"),new g("Value","value",3,1).setTooltip("The amount of damage to deal"),new F("True Damage","true").setTooltip("Whether to deal true damage. True damage ignores armor and all plugin checks, and doesn not have a damage animation nor knockback"),new R("Classifier","classifier","default").setTooltip("The type of damage to deal. Can act as elemental damage or fake physical damage"),new F("Apply Knockback","knockback",!0).setTooltip("Whether the damage will inflict knockback. Ignored if it is True Damage"),new _("Damage Cause","cause",["Contact","Custom","Entity Attack","Entity Sweep Attack","Projectile","Suffocation","Fall","Fire","Fire Tick","Melting","Lava","Drowning","Block Explosion","Entity Explosion","Void","Lightning","Suicide","Starvation","Poison","Magic","Wither","Falling Block","Thorns","Dragon Breath","Fly Into Wall","Hot Floor","Cramming","Dryout","Freeze","Sonic Boom"],"Custom").setTooltip("Damage Cause considered by the server. This will have influence over the death message and ProRPGItems' defenses").requireValue("true",[!1])]},!1)}};let qa=fi;r(qa,"new",()=>new fi);const mi=class extends O{constructor(){super({name:"Damage Buff",description:"Modifies the physical damage dealt by each target by a multiplier or a flat amount for a limited duration. Negative flat amounts or multipliers less than one will reduce damage dealt while the opposite will increase damage dealt. (e.g. a 5% damage buff would be a multiplier or 1.05)",data:[new _("Type","type",["Flat","Multiplier"],"Flat").setTooltip("The type of buff to apply. Flat increases damage by a fixed amount while multiplier increases it by a percentage"),new F("Skill Damage","skill").setTooltip("Whether to buff skill damage. If false, it will affect physical damage"),new g("Value","value",1).setTooltip('The amount to increase/decrease the damage by. A negative amoutn with the "Flat" type will decrease damage, similar to a number less than 1 for the multiplier'),new g("Seconds","seconds",3).setTooltip("The duration of the buff in seconds")]},!1)}};let xa=mi;r(xa,"new",()=>new mi);const gi=class extends O{constructor(){super({name:"Damage Lore",description:"Damages each target based on a value found in the lore of the item held by the caster",data:[new _("Hand","hand",["Main","Offhand"],"Main").setTooltip("The hand to check for the item. Offhand items are MC 1.9+ only"),new R("Regex","regex","Damage: {value}").setTooltip("The regex for the text to look for. Use {value} for where the important number should be. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new g("Multiplier","multiplier",1).setTooltip("The multiplier to use on the value to get the actual damage to deal"),new F("True Damage","true").setTooltip("Whether to deal true damage. True damage ignores armor and all plugin checks"),new R("Classifier","classifier","default").setTooltip("The type of damage to deal. Can act as elemental damage or fake physical damage"),new F("Apply Knockback","knockback",!0).setTooltip("Whether the damage will inflict knockback. Ignored if it is True Damage"),new _("Damage Cause","cause",["Contact","Entity Attack","Entity Sweep Attack","Projectile","Suffocation","Fall","Fire","Fire Tick","Melting","Lava","Drowning","Block Explosion","Entity Explosion","Void","Lightning","Suicide","Starvation","Poison","Magic","Wither","Falling Block","Thorns","Dragon Breath","Custom","Fly Into Wall","Hot Floor","Cramming","Dryout","Freeze","Sonic Boom"],"Entity Attack").setTooltip("Damage Cause considered by the server. This will have influence over the death message and ProRPGItems' defenses").requireValue("true",[!1])]},!1)}};let Ha=gi;r(Ha,"new",()=>new gi);const wi=class extends O{constructor(){super({name:"Defense Buff",description:"Modifies the physical damage taken by each target by a multiplier or a flat amount for a limited duration. Negative flag amounts or multipliers less than one will reduce damage taken while the opposite will increase damage taken. (e.g. a 5% defense buff would be a multiplier or 0.95, since you would be taking 95% damage)",data:[new _("Type","type",["Flat","Multiplier"],"Flat").setTooltip("The type of buff to apply. Flat will increase/reduce incoming damage by a fixed amount where Multiplier does it by a percentage of the damage. Multipliers above 1 will increase damage taken while multipliers below 1 reduce damage taken"),new F("Skill Defense","skill").setTooltip("Whether to buff skill defense. If false, it will affect physical defense"),new g("Value","value",1).setTooltip("The amount to increase/decrease incoming damage by"),new g("Seconds","seconds",3).setTooltip("The duration of the buff in seconds")]},!1)}};let Ca=wi;r(Ca,"new",()=>new wi);const yi=class extends O{constructor(){super({name:"Delay",description:"Applies child components after a delay",data:[new g("Delay","delay",2).setTooltip("The amount of time to wait before applying child components in seconds")]},!0)}};let Wa=yi;r(Wa,"new",()=>new yi);const Ti=class extends O{constructor(){super({name:"Disguise",description:"Disguises each target according to the settings. This mechanic requires the LibsDisguise plugin to be installed on your server",data:[new g("Duration","duration",-1).setTooltip("How long to apply the disguise for in seconds. Use a negative number to permanently disguise the targets"),new _("Type","type",["Mob","Player","Misc"],"Mob").setTooltip("The type of disguise to use, as defined by the LibsDisguise plugin"),new _("Mob","mob",tc,"Zombie").requireValue("type",["Mob"]).setTooltip("The type of mob to disguise the target as"),new F("Adult","adult",!0).requireValue("type",["Mob"]).setTooltip("Whether to use the adult variant of the mob"),new R("Player","player","Eniripsa96").requireValue("type",["Player"]).setTooltip("The player to disguise the target as"),new _("Misc","misc",ac,"Painting").requireValue("type",["Misc"]).setTooltip("The object to disguise the target as"),new oe("Data","data",0).requireValue("misc",["Area effect cloud","Armor stand","Arrow","Boat","Dragon fireball","Egg","Ender crystal","Ender pearl","Ender signal","Experience orb","Fireball","Firework","Fishing hook","Item frame","Leash hitch","Minecart","Minecart chest","Minecart command","Minecart furnace","Minecart hopper","Minecart mob spawner","Minecart tnt","Painting","Primed tnt","Shulker bullet","Snowball","Spectral arrow","Splash potion","Thrown exp bottle","Wither skull"]).setTooltip("Data value to use for the disguise type. What it does depends on the disguise"),new We(!1,"Anvil").requireValue("misc",["Dropped Item","Falling Block"]).setTooltip("Material to use for the disguise type. Note that items used for falling block will not function")]},!1)}};let Ba=Ti;r(Ba,"new",()=>new Ti);const vi=class extends O{constructor(){super({name:"Durability",description:"Lowers the durability of a held item",data:[new g("Amount","amount",1).setTooltip("Amount to reduce the item's durability by"),new F("Offhand","offhand").setTooltip("Whether to apply to the offhand slot")]},!1)}};let Ua=vi;r(Ua,"new",()=>new vi);const bi=class extends O{constructor(){super({name:"Explosion",description:"Causes an explosion at the current target's position",data:[new g("Power","power",3).setTooltip("The strength of the explosion"),new F("Damage Blocks","damage").setTooltip("Whether to damage blocks with the explosion"),new F("Fire","fire").setTooltip("Whether to set affected blocks on fire")]},!1)}};let Ga=bi;r(Ga,"new",()=>new bi);const ki=class extends O{constructor(){super({name:"Fire",description:"Sets the target on fire for a duration",data:[new g("Damage","damage",1).setTooltip("The damage dealt by each fire tick"),new g("Seconds","seconds",3,1).setTooltip("The duration of the fire in seconds")]},!1)}};let Ka=ki;r(Ka,"new",()=>new ki);const _i=class extends O{constructor(){super({name:"Flag",description:"Marks the target with a flag for a duration. Flags can be checked by other triggers, spells or the related for interesting synergies and effects",data:[new R("Key","key","key").setTooltip("The unique string for the flag. Use the same key when checking it in a Flag Condition"),new g("Seconds","seconds",3,1).setTooltip("The duration the flag should be set for. To set one indefinitely, use Flag Toggle")]})}};let za=_i;r(za,"new",()=>new _i);const Ai=class extends O{constructor(){super({name:"Flag Clear",description:"Clears a flag from the target",data:[new R("Key","key","key").setTooltip("The unique string for the flag. This should match that of the mechanic that set the flag to begin with")]})}};let Ya=Ai;r(Ya,"new",()=>new Ai);const Ei=class extends O{constructor(){super({name:"Flag Toggle",description:"Toggles a flag on or off for the target. This can be used to make toggle effects",data:[new R("Key","key","key").setTooltip("The unique string for the flag. Use the same key when checking it in a Flag Condition")]})}};let ja=Ei;r(ja,"new",()=>new Ei);const Si=class extends O{constructor(){super({name:"Food",description:"Adds or removes to a player's hunger and saturation",data:[new g("Food","food",1,1).setTooltip("The amount of food to give. Use a negative number to lower the food meter"),new g("Saturation","saturation").setTooltip("How much saturation to give. Use a negative number to lower saturation. This is the hidden value that determines how long until food starts going down")]},!1)}};let Za=Si;r(Za,"new",()=>new Si);const Di=class extends O{constructor(){super({name:"Forget Targets",description:'Clears targets stored by the "Remember Targets" mechanic',data:[new R("Key","key","key").setTooltip("The unique key the targets were stored under")]},!1)}};let Xa=Di;r(Xa,"new",()=>new Di);const Ii=class extends O{constructor(){super({name:"Heal",description:"Restores health to each target",data:[new _("Type","type",["Health","Percent"],"Health").setTooltip("The unit to use for the amount of health to restore. Health restores a flat amount while Percent restores a percentage of their max health"),new g("Value","value",3,1).setTooltip("The amount of health to restore")]},!1)}};let Ja=Ii;r(Ja,"new",()=>new Ii);const $i=class extends O{constructor(){super({name:"Health Set",description:"Sets the target's health to the specified amount, ignoring resistances, damage buffs, and so on",data:[new g("Health","health",1).setTooltip("The health to set to")]},!1)}};let Qa=$i;r(Qa,"new",()=>new $i);const Pi=class extends O{constructor(){super({name:"Held Item",description:"Sets the held item slot of the target player. This will do nothing if trying to set it to a skill slot",data:[new g("Slot","slot").setTooltip("The slot to set it to")]},!1)}};let Ma=Pi;r(Ma,"new",()=>new Pi);const Oi=class extends O{constructor(){super({name:"Immunity",description:"Provides damage immunity from one source for a duration",data:[new _("Type","type",Do,"Poison").setTooltip("The damage type to give an immunity for"),new g("Seconds","seconds",3).setTooltip("How long to give an immunity for"),new g("Multiplier","multiplier").setTooltip("The multiplier for the incoming damage. Use 0 if you want full immunity")]})}};let es=Oi;r(es,"new",()=>new Oi);const Li=class extends O{constructor(){super({name:"Interrupt",description:"Interrupts any channeling being done by each target if applicable"})}};let ts=Li;r(ts,"new",()=>new Li);const Fi=class extends O{constructor(){super({name:"Item",description:"Gives each player target the item defined by the settings",data:[...lo()]})}};let as=Fi;r(as,"new",()=>new Fi);const Vi=class extends O{constructor(){super({name:"Item Drop",description:"Spawns a dropped item defined by the settings at the specified location",data:[new g("Pickup Delay","pickup_delay",10).setTooltip("How many ticks must pass before the item can be picked up, in ticks"),new g("Duration","duration",6e3).setTooltip("The time after which the item will despawn if not picked up, in ticks. Caps at 6000"),...lo(),new ke("Offset"),new g("Forward offset","forward").setTooltip("How far forward in blocks to teleport. A negative value teleports backwards"),new g("Upward offset","upward").setTooltip("How far upward in blocks to teleport. A negative value teleports downward"),new g("Right offset","right").setTooltip("How far to the right in blocks to teleport. A negative value teleports to the left")]})}};let ss=Vi;r(ss,"new",()=>new Vi);const Ri=class extends O{constructor(){super({name:"Item Projectile",description:"Launches a projectile using an item as its visual that applies child components upon landing. The target passed on will be the collided target or the location where it landed if it missed",data:[new _("Group","group",["Ally","Enemy"],"Enemy").setTooltip("The alignment of targets to hit"),...lo(),...Po(),...co(!0)]},!0)}};let os=Ri;r(os,"new",()=>new Ri);const Ni=class extends O{constructor(){super({name:"Item Remove",description:"Removes an item from a player inventory. This does nothing to mobs",data:[new g("Amount","amount",1).setTooltip("The amount of the item needed in the player's inventory"),...je()]},!1)}};let ns=Ni;r(ns,"new",()=>new Ni);const qi=class extends O{constructor(){super({name:"Launch",description:"Launches the target relative to their forward direction. Use negative values to go in the opposite direction (e.g. negative forward makes the target go backwards)",data:[new _("Relative","relative",["Target","Caster","Between"],"Target").setTooltip('Determines what is considered "forward". Target uses the direction the target is facing, Caster uses the direction the caster is facing, and Between uses the direction from the caster to the target'),new g("Forward Speed","forward").setTooltip("The speed to give the target in the direction they are facing"),new g("Upward Speed","upward",2,.5).setTooltip("The speed to give the target upwards"),new g("Right Speed","right").setTooltip("The speed to give the target to their right")]},!1)}};let is=qi;r(is,"new",()=>new qi);const xi=class extends O{constructor(){super({name:"Lightning",description:"Strikes lightning on or near the target, applying child components to the struck targets. Negative offsets will offset it in the opposite direction (e.g. negative forward offset puts it behind the target)",data:[new g("Damage","damage",5).setTooltip("The damage dealt by the lightning bolt"),new _("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of targets to hit"),new F("Include Caster","caster").setTooltip("Whether the lightning strike can hit the caster"),new ke("Offset"),new g("Forward Offset","forward").setTooltip("How far in front of the target in blocks to place the lightning"),new g("Right Offset","right").setTooltip("How far to the right of the target in blocks to place the lightning")]},!0)}};let ls=xi;r(ls,"new",()=>new xi);const Hi=class extends O{constructor(){super({name:"Mana",description:"Restores or deducts mana from the target",data:[new _("Type","type",["Mana","Percent"],"Mana").setTooltip("The unit to use for the amount of mana to restore/drain. Mana does a flat amount while Percent does a percentage of their max mana"),new g("Value","value",1).setTooltip("The amount of mana to restore/drain")]},!1)}};let rs=Hi;r(rs,"new",()=>new Hi);const Ci=class extends O{constructor(){super({name:"Message",description:"Sends a message to each player target. To include numbers from Value mechanics, use the filters {<key>} where <key> is the key the value is stored under",data:[new R("Message","message","text").setTooltip(`The message to display. {player} = caster's name, {target} = target's name, {targetUUID} = target's UUID (useful if targets are non players), &lc: "{", &rc: "}", &sq: "'"`)]})}};let cs=Ci;r(cs,"new",()=>new Ci);const Wi=class extends O{constructor(){super({name:"Mine",description:"Destroys a selection of blocks at the location of the target",data:[new _("Material","materials",()=>["Origin",...Sr()],["Origin"],!0).setTooltip("The types of blocks allowed to be broken. 'Origin' refers to the material at the targeted location"),new F("Drop","drop",!0).setTooltip("Whether to create drops for the destroyed blocks"),new _("Tool","tool",()=>["Caster","Target",...eo()],"Diamond pickaxe").requireValue("drop",[!0]).setTooltip("What tool to use when breaking the blocks. This allows to take into account the fact that, for example, Diamond Ore does not drop when mined with a Stone Pickaxe, as well as to consider enchantments like Looting and Silk Touch. 'Caster' an 'Target' refers to the items in their respective main hands"),new _("Shape","shape",["Sphere","Cuboid"],"Sphere").setTooltip("The shape of the region to mine"),new g("Radius","radius",2).requireValue("shape",["Sphere"]).setTooltip("The radius of the sphere, in blocks"),new g("Width (X)","width",3).requireValue("shape",["Cuboid"]).setTooltip("The width of the cuboid, in blocks"),new g("Height (Y)","height",3).requireValue("shape",["Cuboid"]).setTooltip("The height of the cuboid, in blocks"),new g("Depth (Z)","depth",3).requireValue("shape",["Cuboid"]).setTooltip("The depth of the cuboid, in blocks"),new ke("Offset"),new g("Forward Offset","forward").setTooltip("How far forward in front of the target the region should be in blocks. A negative value will put it behind"),new g("Upward Offset","upward").setTooltip("How far above the target the region should be in blocks. A negative value will put it below"),new g("Right Offset","right").setTooltip("How far to the right the region should be of the target. A negative value will put it to the left")]})}};let us=Wi;r(us,"new",()=>new Wi);const Bi=class extends O{constructor(){super({name:"Money",description:"Adds or multiplies the target's balance by some amount (requires Vault and an economy plugin). Fails if the resulting balance is not within the range allowed by the economy plugin",data:[new _("Type","type",["Add","Multiply"],"Add").setTooltip("Whether the target's balance will be added or multiplied by the set amount"),new g("Amount","amount",5).setTooltip("The amount that the target's balance will be added or multiplied by. Can be negative"),new F("Allows negative","allows_negative").setTooltip("Whether the mechanic will be executed even if it will result in the target having a negative balance")]})}};let hs=Bi;r(hs,"new",()=>new Bi);const Ui=class extends O{constructor(){super({name:"Particle",description:"Plays a particle effect about the target",data:[...ro(),new ke("Offset"),new X("Forward Offset","forward").setTooltip("How far forward in front of the target in blocks to play the particles. A negative value will go behind"),new X("Upward Offset","upward").setTooltip("How far above the target in blocks to play the particles. A negative value will go below"),new X("Right Offset","right").setTooltip("How far to the right of the target to play the particles. A negative value will go to the left")]})}};let ps=Ui;r(ps,"new",()=>new Ui);const Gi=class extends O{constructor(){super({name:"Particle Animation",description:"Plays an animated particle effect at the location of each target over time by applying various transformations",data:[new oe("Steps","steps",1).setTooltip("The number of times to play particles and apply translations each application"),new X("Frequency","frequency",.05).setTooltip("How often to apply the animation in seconds. 0.05 is the fastest (1 tick). Lower than that will act the same"),new oe("Angle","angle",0).setTooltip("How far the animation should rotate over the duration in degrees"),new oe("Start Angle","start",0).setTooltip("The starting orientation of the animation. Horizontal translations and the forward/right offsets will be based off of this"),new g("Duration","duration",5).setTooltip("How long the animation should last for in seconds"),new g("H-Translation","h-translation").setTooltip("How far the animation moves horizontally relative to the center over a cycle. Positive values make it expand from the center while negative values make it contract"),new g("V-Translation","v-translation").setTooltip("How far the animation moves vertically over a cycle. Positive values make it rise while negative values make it sink"),new oe("H-Cycles","h-cycles",1).setTooltip("How many times to move the animation position throughout the animation. Every other cycle moves it back to where it started. For example, two cycles would move it out and then back in"),new oe("V-Cycles","v-cycles",1).setTooltip("How many times to move the animation position throughout the animation. Every other cycle moves it back to where it started. For example, two cycles would move it up and then back down"),...ro(),new ke("Offset"),new X("Forward Offset","forward",0).setTooltip("How far forward in front of the target in blocks to play the particles. A negative value will go behind"),new X("Upward Offset","upward",0).setTooltip("How far above the target in blocks to play the particles. A negative value will go below"),new X("Right Offset","right",0).setTooltip("How far to the right of the target to play the particles. A negative value will go to the left"),new F("Rotate w/ Player","-with-rotation").setTooltip("Whether to follow the rotation of the player for the effect")]})}};let ds=Gi;r(ds,"new",()=>new Gi);const Ki=class extends O{constructor(){super({name:"Particle Effect",description:"Plays a particle effect that follows the current target, using formulas to determine shape, size, and motion",data:[...co(!1)]})}};let fs=Ki;r(fs,"new",()=>new Ki);const zi=class extends O{constructor(){super({name:"Particle Projectile",description:"Launches a projectile using particles as its visual that applies child components upon landing. The target passed on will be the collided target or the location where it landed if it missed",data:[new X("Gravity","gravity").setTooltip("How much gravity to apply each tick. Negative values make it fall while positive values make it rise"),new F("Pierce","pierce").setTooltip("Whether this projectile should pierce through initial targets and continue hitting those behind them"),new _("Group","group",["Ally","Enemy"],"Enemy").setTooltip("The alignment of targets to hit"),...Po(),...ro(),new X("Frequency","frequency",.05).setTooltip("How often to play a particle effect where the projectile is. It is recommended not to change this value unless there are too many particles playing"),...co(!0)]},!0)}};let ms=zi;r(ms,"new",()=>new zi);const Yi=class extends O{constructor(){super({name:"Passive",description:"Applies child components continuously every period. The seconds value below is the period or how often it applies",data:[new g("Seconds","seconds",1).setTooltip("The delay in seconds between each application")]},!0)}};let gs=Yi;r(gs,"new",()=>new Yi);const ji=class extends O{constructor(){super({name:"Permission",description:"Grants each player target a permission for a limited duration. This mechanic requires Vault with an accompanying permissions plugin in order to work",data:[new R("Permission","perm","plugin.perm.key").setTooltip("The permission to give to the player"),new g("Seconds","seconds",3).setTooltip("How long in seconds to give the permission to the player")]},!0)}};let ws=ji;r(ws,"new",()=>new ji);const Zi=class extends O{constructor(){super({name:"Potion",description:"Applies a potion effect to the target for a duration",data:[new _("Potion","potion",Dr,"Absorption").setTooltip("The type of potion effect to apply"),new F("Ambient Particles","ambient",!0).setTooltip("Whether to show ambient particles"),new g("Tier","tier",1).setTooltip("The strength of the potion"),new g("Seconds","seconds",3,1).setTooltip("How long to apply the effect for")]},!1)}};let ys=Zi;r(ys,"new",()=>new Zi);const Xi=class extends O{constructor(){super({name:"Potion Projectile",description:"Drops a splash potion from each target that does not apply potion effects by default. This will apply child elements when the potion lands. The targets supplied will be everything hit by the potion. If nothing is hit by the potion, the target will be the location it landed",data:[new Ne("Color","color","#ff0000").setTooltip("The hex color code to use for the potion"),new _("Group","group",["Ally","Enemy","Both"],"Enemy").setTooltip("The alignment of entities to hit"),new F("Linger","linger",!1).setTooltip("Whether the potion should be a lingering potion (for 1.9+ only)")]},!0)}};let Ts=Xi;r(Ts,"new",()=>new Xi);const Ji=class extends O{constructor(){super({name:"Projectile",description:"Launches a projectile that applies child components on hit. The target supplied will be the struck target",data:[new _("Projectile","projectile",sc,"Arrow").setTooltip("The type of projectile to fire"),new F("Flaming","flaming",!1).setTooltip("Whether to make the launched projectiles on fire"),new _("Cost","cost",["None","All","One"],"None").setTooltip(`The item cost of the skill. "One" will only charge the player 1 item of it's type, whereas "All" will charge 1 for each fired projectile`),...Po(),...ro(),...co(!0)]},!0)}};let vs=Ji;r(vs,"new",()=>new Ji);const Qi=class extends O{constructor(){super({name:"Purge",description:"Purges the target of positive potion effects or statuses",data:[new _("Potion","potion",oc,void 0,!0).setTooltip("The potion effect to remove from the target, if any"),new _("Status","status",["All","Absorb","Invincible"],"All",!0).setTooltip("The status to remove from the target, if any")]},!1)}};let bs=Qi;r(bs,"new",()=>new Qi);const Mi=class extends O{constructor(){super({name:"Push",description:"Pushes the target relative to the caster. This will do nothing if used with the caster as the target. Positive numbers apply knockback while negative numbers pull them in",data:[new _("Type","type",["Fixed","Inverse","Scaled"],"Fixed").setTooltip("How to scale the speed based on relative position. Fixed does the same speed to all targets. Inverse pushes enemies farther away faster. Scaled pushes enemies closer faster"),new g("Speed","speed",3,1).setTooltip("How fast to push the target away. Use a negative value to pull them closer"),new R("Source","source","none").setTooltip("The source to push/pull from. This should be a key used in a Remember Targets mechanic. If no targets are remembered, this will default to the caster")]},!1)}};let ks=Mi;r(ks,"new",()=>new Mi);const el=class extends O{constructor(){super({name:"Remember Targets",description:"Stores the current targets for later use under a specified key",data:[new R("Key","key","target").setTooltip('The unique key to store the targets under. The "Remember" target will use this key to apply effects to the targets later on')]},!1)}};let _s=el;r(_s,"new",()=>new el);const tl=class extends O{constructor(){super({name:"Repeat",description:"Applies child components multiple times. When it applies them is determined by the delay (seconds before the first application) and period (seconds between successive applications)",data:[new g("Repetitions","repetitions",3).setTooltip("How many times to activate child components"),new X("Period","period",1).setTooltip("The time in seconds between each time applying child components"),new X("Delay","delay").setTooltip("The initial delay before starting to apply child components"),new F("Stop on Fail","stop-on-fail",!1).setTooltip("Whether to stop the repeat task early if the effects fail")]},!0)}};let As=tl;r(As,"new",()=>new tl);const al=class extends O{constructor(){super({name:"Sound",description:"Plays a sound at the target's location",data:[new _("Sound","sound",()=>["Custom",...nc()],"Ambient Cave").setTooltip("The sound clip to play. Select 'Custom' to enter custom sounds from your resource pack"),new R("Custom sound name","custom","myrp:some_sound").requireValue("sound",["Custom"]).setTooltip("Namespaced key of your custom sound"),new g("Volume","volume",100).setTooltip("The volume of the sound as a percentage. Numbers above 100 will not get any louder, but will be heard from a farther distance"),new g("Pitch","pitch",1).setTooltip("The pitch of the sound as a numeric speed multiplier between 0.5 and 2")]},!1)}};let Es=al;r(Es,"new",()=>new al);const sl=class extends O{constructor(){super({name:"Stat",description:"Gives a player bonus stat temporarily",data:[new R("Stat","key","health").setTooltip("The name of the stat to add to"),new _("Operation","operation",["ADD_NUMBER","MULTIPLY_PERCENTAGE"],"ADD_NUMBER").setTooltip("The operation on the original value by amount, ADD_NUMBER: Scalar adding, MULTIPLY_PERCENTAGE: Multiply the value by amount"),new g("Amount","amount",5,2).setTooltip("The amount to use with the operation"),new g("Seconds","seconds",3).setTooltip("How long in seconds to give the stat to the player"),new F("Stackable","stackable").setTooltip("Whether applying multiple times stacks the effects")]})}};let Ss=sl;r(Ss,"new",()=>new sl);const ol=class extends O{constructor(){super({name:"Status",description:"Applies a status effect to the target for a duration",data:[new _("Status","status",["Absorb","Curse","Disarm","Invincible","Root","Silence","Stun"],"Stun").setTooltip("The status to apply"),new g("Duration","duration",3,1).setTooltip("How long in seconds to apply the status")]})}};let Ds=ol;r(Ds,"new",()=>new ol);const nl=class extends O{constructor(){super({name:"Taunt",description:"Draws aggro of targeted creatures. Regular mobs are set to attack the caster. The Spigot/Bukkit API for this was not functional on older versions, so it may not work on older servers. For MythicMobs, this uses their aggro system using the amount chosen below",data:[new g("Amount","amount",1).setTooltip("The amount of aggro to apply if MythicMobs is active. Use negative amounts to reduce aggro")]},!1)}};let Is=nl;r(Is,"new",()=>new nl);const il=class extends O{constructor(){super({name:"Trigger",description:"Listens for a trigger on the current targets for a duration",data:[new _("Trigger","trigger",["Block Break","Block Place","Crouch","Death","Drop Item","Environment Damage","Fishing","Fishing Bite","Fishing Fail","Fishing Grab","Fishing Ground","Fishing Reel","Item Swap","Kill","Land","Launch","Left Click","Move","Physical Damage","Right Click","Skill Damage","Took Physical Damage","Took Skill Damage"],"Death").setTooltip("The trigger to listen for"),new g("Duration","duration",5).setTooltip("How long to listen to the trigger for"),new F("Stackable","stackable",!0).setTooltip("Whether different players (or the same player) can listen to the same target at the same time"),new F("Once","once",!0).setTooltip("Whether the trigger should only be used once each cast. When false, the trigger can execute as many times as it happens for the duration"),new _("Material","material",Sr,["Any"],!0).requireValue("trigger",["Block Break","Block Place"]).setTooltip("The type of block expected to be handled"),new oe("Data","data",-1).requireValue("trigger",["Block Break","Block Place"]).setTooltip("The expected data value of the block (-1 for any data value)"),new _("Crouch","crouch",["Crouch","Dont crouch","Both"],"Crouch").requireValue("trigger",["Left Click","Right Click"]).setTooltip("If the player has to be crouching in order for this trigger to function"),new _("Type","type",["Start Crouching","Stop Crouching","Both"],"Start Crouching").requireValue("trigger",["Crouch"]).setTooltip("Whether you want to apply components when crouching or not crouching"),new _("Drop multiple","drop multiple",["True","False","Ignore"],"Ignore").requireValue("trigger",["Drop Item"]).setTooltip("Whether the player has to drop multiple items or a single item"),new _("Type","type",Do,"FALL").requireValue("trigger",["Environment Damage"]).setTooltip("The source of damage to apply for"),new F("Cancel swap","cancel",!0).requireValue("trigger",["Item Swap"]).setTooltip("True cancels the item swap. False allows the item swap"),new X("Min Distance","min-distance",0).requireValue("trigger",["Land"]).setTooltip("The minimum distance the player should fall before effects activating"),new _("Type","type",Ar(),"Any").requireValue("trigger",["Launch"]).setTooltip("The type of projectile that should be launched"),new _("Type","type",["Both","Melee","Projectile"],"Both").requireValue("trigger",["Physical Damage","Took Physical Damage"]).setTooltip("The type of damage dealt"),new R("Category","category","").requireValue("trigger",["Skill Damage","Took Skill Damage"]).setTooltip("The type of skill damage to apply for. Leave this empty to apply to all skill damage"),new F("Target Listen Target","target",!0).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("True makes children target the target that has been listened to. False makes children target the entity fighting the target entity"),new X("Min Damage","dmg-min",0).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("The minimum damage that needs to be dealt"),new X("Max Damage","dmg-max",999).requireValue("trigger",["Physical Damage","Skill Damage","Took Physical Damage","Took Skill Damage"]).setTooltip("The maximum damage that needs to be dealt")]},!0)}};let $s=il;r($s,"new",()=>new il);const ll=class extends O{constructor(){super({name:"Value Add",description:"Adds to a stored value under a unique key for the caster. If the value wasn't set before, this will set the value to the given amount",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new g("Amount","amount",1).setTooltip("The amount to add to the value")]},!1)}};let Ps=ll;r(Ps,"new",()=>new ll);const rl=class extends O{constructor(){super({name:"Value Attribute",description:"Loads a player's attribute count for a specific attribute as a stored value to be used in other mechanics",data:[new R("Key","key","attribute").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new R("Attribute","attribute","Vitality").setTooltip("The name of the attribute you are loading the value of")]},!1)}};let Os=rl;r(Os,"new",()=>new rl);const cl=class extends O{constructor(){super({name:"Value Copy",description:"Copies a stored value from the caster to the target or vice versa",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new R("Destination","destination","value").setTooltip("The key to copy the original value to"),new F("To target","to-target",!0).setTooltip("The amount to add to the value")]},!1)}};let Ls=cl;r(Ls,"new",()=>new cl);const ul=class extends O{constructor(){super({name:"Value Distance",description:"Stores the distance between the target and the caster into a value",data:[new R("Key","key","attribute").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value")]},!1)}};let Fs=ul;r(Fs,"new",()=>new ul);const hl=class extends O{constructor(){super({name:"Value Health",description:"Stores the target's current health as a value under a given key for the caster",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Type","type",["Current","Max","Missing","Percent"],"Current").setTooltip("Current provides the health the target has, max provides their total health, missing provides how much health they have lost, and percent is the ratio of health to total health")]},!1)}};let Vs=hl;r(Vs,"new",()=>new hl);const pl=class extends O{constructor(){super({name:"Value Location",description:"Loads the first target's current location into a stored value for use at a later time",data:[new R("Key","key","location").setTooltip("The unique key to store the location under. This key can be used in place of attribute values to use the stored value")]},!1)}};let Rs=pl;r(Rs,"new",()=>new pl);const dl=class extends O{constructor(){super({name:"Value Lore",description:"Loads a value from a held item's lore into a stored value under the given unique key for the caster",data:[new R("Key","key","lore").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Hand","hand",["Main","Offhand"],"Main").setTooltip("The hand to check for the item. Offhand items are MC 1.9+ only"),new R("Regex","regex","Damage: {value}").setTooltip("The regex string to look for, using {value} as the number to store. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new g("Multiplier","multiplier",1).setTooltip("The multiplier for the acquired value. If you want the value to remain unchanged, leave this value at 1")]},!1)}};let Ns=dl;r(Ns,"new",()=>new dl);const fl=class extends O{constructor(){super({name:"Value Lore Slot",description:"Loads a value from an item's lore into a stored value under the given unique key for the caster",data:[new R("Key","key","lore").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new oe("Slot","slot",9).setTooltip("The slot of the inventory to fetch the item from. Slots 0-8 are the hotbar, 9-35 are the main inventory, 36-39 are armor, and 40 is the offhand slot"),new R("Regex","regex","Damage: {value}").setTooltip("The regex string to look for, using {value} as the number to store. If you do not know about regex, consider looking it up on Wikipedia or avoid using major characters such as [ ] { } ( ) . + ? * ^ \\ |"),new g("Multiplier","multiplier",1).setTooltip("The multiplier for the acquired value. If you want the value to remain unchanged, leave this value at 1")]},!1)}};let qs=fl;r(qs,"new",()=>new fl);const ml=class extends O{constructor(){super({name:"Value Mana",description:"Stores the target player's current mana as a value under a given key for the caster",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Type","type",["Current","Max","Missing","Percent"],"Current").setTooltip("Current provides the mana the target has, max provides their total mana, missing provides how much mana they have lost, and percent is the ratio of health to total mana")]},!1)}};let xs=ml;r(xs,"new",()=>new ml);const gl=class extends O{constructor(){super({name:"Value Multiply",description:"Multiplies a stored value under a unique key for the caster. If the value wasn't set before, this will not do anything",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new g("Multiplier","multiplier",1).setTooltip("The amount to multiply the value by")]},!1)}};let Hs=gl;r(Hs,"new",()=>new gl);const wl=class extends O{constructor(){super({name:"Value Placeholder",description:"Uses a placeholder string and stores it as a value for the caster",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Type","type",["Number","String"],"Number").setTooltip("The type of value to store. Number values require numeric placeholders. String values can be used in messages or commands"),new R("Placeholder","placeholder","%player_food_level%").setTooltip("The placeholder string to use. Can contain multiple placeholders if using the String type")]},!1)}};let Cs=wl;r(Cs,"new",()=>new wl);const yl=class extends O{constructor(){super({name:"Value Random",description:"Stores a specified value under a given key for the caster",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new _("Type","type",["Normal","Triangular"],"Normal").setTooltip("The type of random to use. Triangular favors numbers in the middle, similar to rolling two dice"),new g("Min","min").setTooltip("The minimum value it can be"),new g("Max","max").setTooltip("The maximum value it can be")]},!1)}};let Ws=yl;r(Ws,"new",()=>new yl);const Tl=class extends O{constructor(){super({name:"Value Set",description:"Stores a specified value under a given key for the caster",data:[new R("Key","key","value").setTooltip("The unique key to store the value under. This key can be used in place of attribute values to use the stored value"),new g("Value","value",1).setTooltip("The value to store under the key")]},!1)}};let Bs=Tl;r(Bs,"new",()=>new Tl);const vl=class extends O{constructor(){super({name:"Warp",description:"Warps the target relative to their forward direction. Use negative numbers to go in the opposite direction (e.g. negative forward will cause the target to warp backwards)",data:[new F("Through Walls","walls").setTooltip("Whether to allow the target to teleport through walls"),new ke("Position"),new g("Forward","forward",3,1).setTooltip("How far forward in blocks to teleport. A negative value teleports backwards"),new g("Upward","upward").setTooltip("How far upward in blocks to teleport. A negative value teleports downward"),new g("Right","right").setTooltip("How far to the right in blocks to teleport. A negative value teleports to the left")]},!1)}};let Us=vl;r(Us,"new",()=>new vl);const bl=class extends O{constructor(){super({name:"Warp Location",description:"Warps the target to a specified location",data:[new R('World (or "current")',"world","current").setTooltip("The name of the world that the location is in"),new X("X","x",0).setTooltip("The X-coordinate of the desired position"),new X("Y","y",0).setTooltip("The Y-coordinate of the desired position"),new X("Z","z",0).setTooltip("The Z-coordinate of the desired position"),new X("Yaw","yaw",0).setTooltip("The Yaw of the desired position (left/right orientation)"),new X("Pitch","pitch",0).setTooltip("The Pitch of the desired position (up/down orientation)")]},!1)}};let Gs=bl;r(Gs,"new",()=>new bl);const kl=class extends O{constructor(){super({name:"Warp Random",description:"Warps the target in a random direction the given distance",data:[new F("Only Horizontal","horizontal",!0).setTooltip("Whether to limit the random position to the horizontal plane"),new F("Through Walls","walls",!1).setTooltip("Whether to allow the target to teleport through walls"),new g("Distance","distance",3,1).setTooltip("The max distance in blocks to teleport")]},!1)}};let Ks=kl;r(Ks,"new",()=>new kl);const _l=class extends O{constructor(){super({name:"Warp Swap",description:"Switches the location of the caster and the target. If multiple targets are provided, this takes the first one"})}};let zs=_l;r(zs,"new",()=>new _l);const Al=class extends O{constructor(){super({name:"Warp Target",description:"Warps either the target or the caster to the other. This does nothing when the target is the caster",data:[new _("Type","type",["Caster to Target","Target to Caster"],"Caster to Target").setTooltip("The direction to warp the involved targets")]})}};let Ys=Al;r(Ys,"new",()=>new Al);const El=class extends O{constructor(){super({name:"Warp Value",description:"Warps all targets to a location remembered using the Value Location mechanic",data:[new R("Key","key","location").setTooltip("The unique key the location is stored under. This should be the same key used in the Value Location mechanic")]},!1)}};let js=El;r(js,"new",()=>new El);const Sl=class extends O{constructor(){super({name:"Wolf",description:"Summons a wolf on each target for a duration. Child components will start off targeting the wolf so you can add effects to it. You can also give it its own skillset, though Cast triggers will not occur",data:[new _("Collar Color","color",ic,"Black").setTooltip("The color of the collar that the wolf should wear"),new R("Wolf Name","name","{player}'s Wolf").setTooltip("The displayed name of the wolf. Use {player} to embed the caster's name"),new g("Health","health",10).setTooltip("The starting health of the wolf"),new g("Damage","damage",3).setTooltip("The damage dealt by the wolf each attack"),new F("Sitting","sitting",!1).setTooltip("Whether the wolf starts off sitting"),new g("Duration","seconds",10).setTooltip("How long to summon the wolf for"),new g("Amount","amount",1).setTooltip("How many wolves to summon"),new no("Skills","skills",!0).setTooltip("The skills to give the wolf. Skills are executed at the level of the skill summoning the wolf. Skills needing a Cast trigger will not work")]},!0)}};let Zs=Sl;r(Zs,"new",()=>new Sl);const Nu=()=>{Ze.triggers.set({BLOCK_BREAK:{name:"Block Break",component:tt},BLOCK_PLACE:{name:"Block Place",component:at},CAST:{name:"Cast",component:st},CLEANUP:{name:"Cleanup",component:ot},CROUCH:{name:"Crouch",component:nt},DEATH:{name:"Death",component:it},DROP_ITEM:{name:"Drop Item",component:lt},ENV_DAMAGE:{name:"Environment Damage",component:rt},FISHING:{name:"Fishing",component:ct},FISHING_BITE:{name:"Fishing Bite",component:ut},FISHING_FAIL:{name:"Fishing Fail",component:ht},FISHING_GRAB:{name:"Fishing Grab",component:pt},FISHING_GROUND:{name:"Fishing Ground",component:dt},FISHING_REEL:{name:"Fishing Reel",component:ft},INIT:{name:"Initialize",component:mt},ITEM_SWAP:{name:"Item Swap",component:gt},KILL:{name:"Kill",component:wt},LAND:{name:"Land",component:yt},LAUNCH:{name:"Launch",component:Tt},LEFT_CLICK:{name:"Left Click",component:vt},RIGHT_CLICK:{name:"Right Click",component:_t},MOVE:{name:"Move",component:bt},PHYS_DAMAGE:{name:"Physical Damage",component:kt},SKILL_DAMAGE:{name:"Skill Damage",component:Et},SKILL_CAST:{name:"Skill Cast",component:At},TOOK_PHYS:{name:"Took Physical Damage",component:St},TOOK_SKILL:{name:"Took Skill Damage",component:Dt}}),Ze.targets.set({AREA:{name:"Area",component:It},CONE:{name:"Cone",component:$t},LINEAR:{name:"Linear",component:Pt},LOCATION:{name:"Location",component:Ot},NEAREST:{name:"Nearest",component:Lt},OFFSET:{name:"Offset",component:Ft},REMEMBER:{name:"Remember",component:Vt},SELF:{name:"Self",component:Rt},SINGLE:{name:"Single",component:Nt}}),Ze.conditions.set({ALTITUDE:{name:"Altitude",component:qt},ARMOR:{name:"Armor",component:xt},ATTRIBUTE:{name:"Attribute",component:Ht},BIOME:{name:"Biome",component:Ct},BLOCK:{name:"Block",component:Wt},BURNING:{name:"Burning",component:Bt},CEILING:{name:"Ceiling",component:Ut},CHANCE:{name:"Chance",component:Gt},CLASS:{name:"Class",component:Kt},CLASS_LEVEL:{name:"Class Level",component:zt},COMBAT:{name:"Combat",component:Yt},CROUCH:{name:"Crouch",component:jt},DIRECTION:{name:"Direction",component:Zt},ELEVATION:{name:"Elevation",component:Xt},ELSE:{name:"Else",component:Jt},ENTITY_TYPE:{name:"Entity Type",component:Qt},FIRE:{name:"Fire",component:Mt},FLAG:{name:"Flag",component:ea},FOOD:{name:"Food",component:ta},GROUND:{name:"Ground",component:aa},HEALTH:{name:"Health",component:sa},INVENTORY:{name:"Inventory",component:na},ITEM:{name:"Item",component:oa},LIGHT:{name:"Light",component:ia},MANA:{name:"Mana",component:la},MONEY:{name:"Money",component:ra},MOUNTED:{name:"Mounted",component:ca},MOUNTING:{name:"Mounting",component:ua},MYTHICMOB_TYPE:{name:"MythicMob Type",component:ha},NAME:{name:"Name",component:pa},OFFHAND:{name:"Offhand",component:da},PERMISSION:{name:"Permission",component:fa},POTION:{name:"Potion",component:ma},SKILL_LEVEL:{name:"Skill Level",component:ga},SLOT:{name:"Slot",component:wa},STATUS:{name:"Status",component:ya},TIME:{name:"Time",component:Ta},TOOL:{name:"Tool",component:va},VALUE:{name:"Value",component:ba},WATER:{name:"Water",component:ka},WEATHER:{name:"Weather",component:_a},WORLD:{name:"World",component:Aa}}),Ze.mechanics.set({ARMOR:{name:"Armor",component:Ea},ARMOR_STAND:{name:"Armor Stand",component:Sa},ARMOR_STAND_POSE:{name:"Armor Stand Pose",component:Da},ATTRIBUTE:{name:"Attribute",component:Ia},BLOCK:{name:"Block",component:$a},BUFF:{name:"Buff",component:Pa},CANCEL:{name:"Cancel",component:Oa},CHANNEL:{name:"Channel",component:Fa},CLEANSE:{name:"Cleanse",component:Va},COMMAND:{name:"Command",component:Ra},COOLDOWN:{name:"Cooldown",component:Na},DAMAGE:{name:"Damage",component:qa},DAMAGE_BUFF:{name:"Damage Buff",component:xa},DAMAGE_LORE:{name:"Damage Lore",component:Ha},DEFENSE_BUFF:{name:"Defense Buff",component:Ca},DELAY:{name:"Delay",component:Wa},DISGUISE:{name:"Disguise",component:Ba},DURABILITY:{name:"Durability",component:Ua},EXPLOSION:{name:"Explosion",component:Ga},FIRE:{name:"Fire",component:Ka},FLAG:{name:"Flag",component:za},FLAG_CLEAR:{name:"Flag Clear",component:Ya},FLAG_TOGGLE:{name:"Flag Toggle",component:ja},FOOD:{name:"Food",component:Za},FORGET_TARGETS:{name:"Forget Targets",component:Xa},HEAL:{name:"Heal",component:Ja},HEALTH_SET:{name:"Health Set",component:Qa},HELD_ITEM:{name:"Held Item",component:Ma},IMMUNITY:{name:"Immunity",component:es},INTERRUPT:{name:"Interrupt",component:ts},ITEM:{name:"Item",component:as},ITEM_DROP:{name:"Item Drop",component:ss},ITEM_PROJECTILE:{name:"Item Projectile",component:os},ITEM_REMOVE:{name:"Item Remove",component:ns},LAUNCH:{name:"Launch",component:is},LIGHTNING:{name:"Lightning",component:ls},MANA:{name:"Mana",component:rs},MESSAGE:{name:"Message",component:cs},MINE:{name:"Mine",component:us},MONEY:{name:"Money",component:hs},PARTICLE:{name:"Particle",component:ps},PARTICLE_ANIMATION:{name:"Particle Animation",component:ds},PARTICLE_EFFECT:{name:"Particle Effect",component:fs},CANCEL_EFFECT:{name:"Cancel Effect",component:La},PARTICLE_PROJECTILE:{name:"Particle Projectile",component:ms},PASSIVE:{name:"Passive",component:gs},PERMISSION:{name:"Permission",component:ws},POTION:{name:"Potion",component:ys},POTION_PROJECTILE:{name:"Potion Projectile",component:Ts},PROJECTILE:{name:"Projectile",component:vs},PURGE:{name:"Purge",component:bs},PUSH:{name:"Push",component:ks},REMEMBER_TARGETS:{name:"Remember Targets",component:_s},REPEAT:{name:"Repeat",component:As},SOUND:{name:"Sound",component:Es},STAT:{name:"Stat",component:Ss},STATUS:{name:"Status",component:Ds},TAUNT:{name:"Taunt",component:Is},TRIGGER:{name:"Trigger",component:$s},VALUE_ADD:{name:"Value Add",component:Ps},VALUE_ATTRIBUTE:{name:"Value Attribute",component:Os},VALUE_COPY:{name:"Value Copy",component:Ls},VALUE_DISTANCE:{name:"Value Distance",component:Fs},VALUE_HEALTH:{name:"Value Health",component:Vs},VALUE_LOCATION:{name:"Value Location",component:Rs},VALUE_LORE:{name:"Value Lore",component:Ns},VALUE_LORE_SLOT:{name:"Value Lore Slot",component:qs},VALUE_MANA:{name:"Value Mana",component:xs},VALUE_MULTIPLY:{name:"Value Multiply",component:Hs},VALUE_PLACEHOLDER:{name:"Value Placeholder",component:Cs},VALUE_RANDOM:{name:"Value Random",component:Ws},VALUE_SET:{name:"Value Set",component:Bs},WARP:{name:"Warp",component:Us},WARP_LOC:{name:"Warp Location",component:Gs},WARP_RANDOM:{name:"Warp Random",component:Ks},WARP_SWAP:{name:"Warp Swap",component:zs},WARP_TARGET:{name:"Warp Target",component:Ys},WARP_VALUE:{name:"Warp Value",component:js},WOLF:{name:"Wolf",component:Zs}}),Ze.initialized.set(!0)};function ir(s,e,t){const a=s.slice();return a[23]=e[t],a}function lr(s){let e,t;return e=new pc({}),{c(){z(e.$$.fragment)},l(a){Y(e.$$.fragment,a)},m(a,o){j(e,a,o),t=!0},i(a){t||(V(e.$$.fragment,a),t=!0)},o(a){N(e.$$.fragment,a),t=!1},d(a){Z(e,a)}}}function rr(s){let e,t=s[23]+"",a;return{c(){e=S("option"),a=Q(t),this.h()},l(o){e=D(o,"OPTION",{});var l=$(e);a=M(l,t),l.forEach(T),this.h()},h(){e.__value=s[23].substring(2),e.value=e.__value},m(o,l){C(o,e,l),y(e,a)},p:Fe,d(o){o&&T(e)}}}function qu(s){let e,t,a,o=Ul,l=[];for(let n=0;n<o.length;n+=1)l[n]=rr(ir(s,o,n));return{c(){e=S("select");for(let n=0;n<l.length;n+=1)l[n].c();this.h()},l(n){e=D(n,"SELECT",{});var c=$(e);for(let i=0;i<l.length;i+=1)l[i].l(c);c.forEach(T),this.h()},h(){s[5]===void 0&&Ie(()=>s[14].call(e))},m(n,c){C(n,e,c);for(let i=0;i<l.length;i+=1)l[i]&&l[i].m(e,null);Nl(e,s[5],!0),t||(a=K(e,"change",s[14]),t=!0)},p(n,c){if(c&0){o=Ul;let i;for(i=0;i<o.length;i+=1){const u=ir(n,o,i);l[i]?l[i].p(u,c):(l[i]=rr(u),l[i].c(),l[i].m(e,null))}for(;i<l.length;i+=1)l[i].d(1);l.length=o.length}c&32&&Nl(e,n[5])},d(n){n&&T(e),_o(l,n),t=!1,a()}}}function xu(s){let e,t,a;function o(n){s[15](n)}let l={left:"Symbols",right:"Text"};return s[6]!==void 0&&(l.data=s[6]),e=new so({props:l}),ie.push(()=>re(e,"data",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&64&&(t=!0,i.data=n[6],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function Hu(s){let e,t,a;function o(n){s[16](n)}let l={};return s[7]!==void 0&&(l.data=s[7]),e=new so({props:l}),ie.push(()=>re(e,"data",o)),{c(){z(e.$$.fragment)},l(n){Y(e.$$.fragment,n)},m(n,c){j(e,n,c),a=!0},p(n,c){const i={};!t&&c&128&&(t=!0,i.data=n[7],ce(()=>t=!1)),e.$set(i)},i(n){a||(V(e.$$.fragment,n),a=!0)},o(n){N(e.$$.fragment,n),a=!1},d(n){Z(e,n)}}}function Cu(s){let e,t,a,o,l,n,c,i,u,h,d,w;return c=new be({props:{label:"Server",tooltip:"This should match your target Spigot server version",$$slots:{default:[qu]},$$scope:{ctx:s}}}),u=new be({props:{label:"Use Symbols",tooltip:"If skill components should use symbols instead of text",$$slots:{default:[xu]},$$scope:{ctx:s}}}),d=new be({props:{label:"Waterfall Animation",tooltip:"If the waterfall animation should play in the sidebar",$$slots:{default:[Hu]},$$scope:{ctx:s}}}),{c(){e=S("h1"),t=Q("Settings"),a=W(),o=S("hr"),l=W(),n=S("div"),z(c.$$.fragment),i=W(),z(u.$$.fragment),h=W(),z(d.$$.fragment),this.h()},l(v){e=D(v,"H1",{});var A=$(e);t=M(A,"Settings"),A.forEach(T),a=B(v),o=D(v,"HR",{}),l=B(v),n=D(v,"DIV",{class:!0});var p=$(n);Y(c.$$.fragment,p),i=B(p),Y(u.$$.fragment,p),h=B(p),Y(d.$$.fragment,p),p.forEach(T),this.h()},h(){b(n,"class","settings-container svelte-uxir0y")},m(v,A){C(v,e,A),y(e,t),C(v,a,A),C(v,o,A),C(v,l,A),C(v,n,A),j(c,n,null),y(n,i),j(u,n,null),y(n,h),j(d,n,null),w=!0},p(v,A){const p={};A&262176&&(p.$$scope={dirty:A,ctx:v}),c.$set(p);const f={};A&262208&&(f.$$scope={dirty:A,ctx:v}),u.$set(f);const m={};A&262272&&(m.$$scope={dirty:A,ctx:v}),d.$set(m)},i(v){w||(V(c.$$.fragment,v),V(u.$$.fragment,v),V(d.$$.fragment,v),w=!0)},o(v){N(c.$$.fragment,v),N(u.$$.fragment,v),N(d.$$.fragment,v),w=!1},d(v){v&&T(e),v&&T(a),v&&T(o),v&&T(l),v&&T(n),Z(c),Z(u),Z(d)}}}function cr(s){let e,t=s[8]?"Saving...":"Saved!",a,o,l;return{c(){e=S("div"),a=Q(t),this.h()},l(n){e=D(n,"DIV",{class:!0});var c=$(e);a=M(c,t),c.forEach(T),this.h()},h(){b(e,"class","saving svelte-uxir0y")},m(n,c){C(n,e,c),y(e,a),l=!0},p(n,c){(!l||c&256)&&t!==(t=n[8]?"Saving...":"Saved!")&&Ce(a,t)},i(n){l||(Ie(()=>{l&&(o||(o=Ye(e,xe,{y:-20},!0)),o.run(1))}),l=!0)},o(n){o||(o=Ye(e,xe,{y:-20},!1)),o.run(0),l=!1},d(n){n&&T(e),n&&o&&o.end()}}}function ur(s){let e,t,a,o;return{c(){e=S("div"),t=Q("Drop to Import"),this.h()},l(l){e=D(l,"DIV",{class:!0});var n=$(e);t=M(n,"Drop to Import"),n.forEach(T),this.h()},h(){b(e,"class","dragging svelte-uxir0y")},m(l,n){C(l,e,n),y(e,t),a||(o=K(e,"dragleave",s[10]),a=!0)},p:Fe,d(l){l&&T(e),a=!1,o()}}}function Wu(s){let e,t,a,o,l,n,c,i,u,h,d,w,v,A,p,f,m,k,E,U,x,se,L=new Date().getFullYear()+"",G,ee,P,H,te,me,de,ye,q,Te,_e;e=new qc({}),a=new Lc({});const Re=s[11].default,ge=hr(Re,s,s[18],null);let le=s[4]&&lr();function $r(I){s[17](I)}let Dl={$$slots:{default:[Cu]},$$scope:{ctx:s}};s[1]!==void 0&&(Dl.open=s[1]),H=new Eo({props:Dl}),ie.push(()=>re(H,"open",$r));let fe=s[2]&&cr(s),ve=s[0]&&ur(s);return{c(){z(e.$$.fragment),t=W(),z(a.$$.fragment),o=W(),l=S("div"),n=S("div"),ge&&ge.c(),c=W(),i=S("div"),u=S("div"),h=S("span"),d=Q("cloud_download"),w=W(),v=S("div"),A=S("span"),p=Q("settings"),f=W(),m=S("div"),k=S("span"),E=Q("save"),U=W(),x=S("footer"),se=Q(" ProMCTeam "),G=Q(L),ee=W(),le&&le.c(),P=W(),z(H.$$.fragment),me=W(),fe&&fe.c(),de=W(),ve&&ve.c(),ye=Se(),this.h()},l(I){Y(e.$$.fragment,I),t=B(I),Y(a.$$.fragment,I),o=B(I),l=D(I,"DIV",{id:!0,class:!0});var ae=$(l);n=D(ae,"DIV",{id:!0,class:!0});var Be=$(n);ge&&ge.l(Be),Be.forEach(T),ae.forEach(T),c=B(I),i=D(I,"DIV",{id:!0,class:!0});var Ue=$(i);u=D(Ue,"DIV",{class:!0,title:!0});var Il=$(u);h=D(Il,"SPAN",{class:!0});var $l=$(h);d=M($l,"cloud_download"),$l.forEach(T),Il.forEach(T),w=B(Ue),v=D(Ue,"DIV",{class:!0,title:!0});var Pl=$(v);A=D(Pl,"SPAN",{class:!0});var Ol=$(A);p=M(Ol,"settings"),Ol.forEach(T),Pl.forEach(T),f=B(Ue),m=D(Ue,"DIV",{class:!0,title:!0});var Ll=$(m);k=D(Ll,"SPAN",{class:!0});var Fl=$(k);E=M(Fl,"save"),Fl.forEach(T),Ll.forEach(T),Ue.forEach(T),U=B(I),x=D(I,"FOOTER",{class:!0});var uo=$(x);se=M(uo," ProMCTeam "),G=M(uo,L),uo.forEach(T),ee=B(I),le&&le.l(I),P=B(I),Y(H.$$.fragment,I),me=B(I),fe&&fe.l(I),de=B(I),ve&&ve.l(I),ye=Se(),this.h()},h(){b(n,"id","body"),b(n,"class","svelte-uxir0y"),Ee(n,"centered",!s[3]),b(l,"id","body-container"),b(l,"class","svelte-uxir0y"),Ee(l,"empty",!s[3]),b(h,"class","material-symbols-rounded svelte-uxir0y"),b(u,"class","button backup svelte-uxir0y"),b(u,"title","Backup All Data"),b(A,"class","material-symbols-rounded svelte-uxir0y"),b(v,"class","button settings svelte-uxir0y"),b(v,"title","Change Settings"),b(k,"class","material-symbols-rounded svelte-uxir0y"),b(m,"class","button save svelte-uxir0y"),b(m,"title","Save"),b(i,"id","floating-buttons"),b(i,"class","svelte-uxir0y"),b(x,"class","svelte-uxir0y")},m(I,ae){j(e,I,ae),C(I,t,ae),j(a,I,ae),C(I,o,ae),C(I,l,ae),y(l,n),ge&&ge.m(n,null),C(I,c,ae),C(I,i,ae),y(i,u),y(u,h),y(h,d),y(i,w),y(i,v),y(v,A),y(A,p),y(i,f),y(i,m),y(m,k),y(k,E),C(I,U,ae),C(I,x,ae),y(x,se),y(x,G),C(I,ee,ae),le&&le.m(I,ae),C(I,P,ae),j(H,I,ae),C(I,me,ae),fe&&fe.m(I,ae),C(I,de,ae),ve&&ve.m(I,ae),C(I,ye,ae),q=!0,Te||(_e=[K(u,"click",s[9]),K(v,"click",s[12]),K(m,"click",s[13])],Te=!0)},p(I,[ae]){ge&&ge.p&&(!q||ae&262144)&&pr(ge,Re,I,I[18],q?fr(Re,I[18],ae,null):dr(I[18]),null),(!q||ae&8)&&Ee(n,"centered",!I[3]),(!q||ae&8)&&Ee(l,"empty",!I[3]),I[4]?le?ae&16&&V(le,1):(le=lr(),le.c(),V(le,1),le.m(P.parentNode,P)):le&&($e(),N(le,1,1,()=>{le=null}),Pe());const Be={};ae&262368&&(Be.$$scope={dirty:ae,ctx:I}),!te&&ae&2&&(te=!0,Be.open=I[1],ce(()=>te=!1)),H.$set(Be),I[2]?fe?(fe.p(I,ae),ae&4&&V(fe,1)):(fe=cr(I),fe.c(),V(fe,1),fe.m(de.parentNode,de)):fe&&($e(),N(fe,1,1,()=>{fe=null}),Pe()),I[0]?ve?ve.p(I,ae):(ve=ur(I),ve.c(),ve.m(ye.parentNode,ye)):ve&&(ve.d(1),ve=null)},i(I){q||(V(e.$$.fragment,I),V(a.$$.fragment,I),V(ge,I),V(le),V(H.$$.fragment,I),V(fe),q=!0)},o(I){N(e.$$.fragment,I),N(a.$$.fragment,I),N(ge,I),N(le),N(H.$$.fragment,I),N(fe),q=!1},d(I){Z(e,I),I&&T(t),Z(a,I),I&&T(o),I&&T(l),ge&&ge.d(I),I&&T(c),I&&T(i),I&&T(U),I&&T(x),I&&T(ee),le&&le.d(I),I&&T(P),Z(H,I),I&&T(me),fe&&fe.d(I),I&&T(de),ve&&ve.d(I),I&&T(ye),Te=!1,Oe(_e)}}}function Bu(s,e,t){let a,o,l,n,c,i;we(s,Ao,P=>t(3,a=P)),we(s,Yr,P=>t(4,o=P)),we(s,Bl,P=>t(5,l=P)),we(s,Cl,P=>t(6,n=P)),we(s,To,P=>t(7,c=P)),we(s,Hl,P=>t(8,i=P));let{$$slots:u={},$$scope:h}=e,d=!1,w=!1,v=!1,A,p;mr(()=>{document.addEventListener("dragover",m),document.addEventListener("drop",E),p=Hl.subscribe(P=>{if(!P){setTimeout(()=>t(2,v=!1),1e3);return}A&&clearTimeout(A),A=setTimeout(()=>t(2,v=!0),1e3)}),Nu()}),gr(()=>{document.removeEventListener("dragover",m),document.removeEventListener("drop",E),p&&p()});const f=()=>{alert("This feature isn't implemented yet")},m=P=>{var H,te,me;((te=(H=P.dataTransfer)==null?void 0:H.types)==null?void 0:te.length)>0&&((me=P.dataTransfer)==null?void 0:me.types[0])=="Files"&&(P.dataTransfer.dropEffect="copy",P.stopPropagation(),P.preventDefault(),t(0,d=!0))},k=()=>{setTimeout(()=>t(0,d=!1),50)},E=P=>{t(0,d=!1);for(let H=0;H<P.dataTransfer.files.length;H++){const te=P.dataTransfer.files[H];te.name.indexOf(".yml")!=-1&&yr(te)}P.stopPropagation(),P.preventDefault()},U=()=>t(1,w=!0),x=()=>kr();function se(){l=Nr(this),Bl.set(l)}function L(P){n=P,Cl.set(n)}function G(P){c=P,To.set(c)}function ee(P){w=P,t(1,w)}return s.$$set=P=>{"$$scope"in P&&t(18,h=P.$$scope)},[d,w,v,a,o,l,n,c,i,f,k,u,U,x,se,L,G,ee,h]}class Zu extends ue{constructor(e){super(),he(this,e,Bu,Wu,pe,{})}}export{Zu as component};
